module.exports = {

"[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clsx": (()=>clsx),
    "default": (()=>__TURBOPACK__default__export__)
});
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}}),
"[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// packages/react/compose-refs/src/compose-refs.tsx
__turbopack_context__.s({
    "composeRefs": (()=>composeRefs),
    "useComposedRefs": (()=>useComposedRefs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
}
function composeRefs(...refs) {
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup == "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
function useComposedRefs(...refs) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(composeRefs(...refs), refs);
}
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// packages/react/slot/src/slot.tsx
__turbopack_context__.s({
    "Root": (()=>Slot),
    "Slot": (()=>Slot),
    "Slottable": (()=>Slottable),
    "createSlot": (()=>createSlot),
    "createSlottable": (()=>createSlottable)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
;
;
;
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        const childrenArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].toArray(children);
        const slottable = childrenArray.find(isSlottable);
        if (slottable) {
            const newElement = slottable.props.children;
            const newChildren = childrenArray.map((child)=>{
                if (child === slottable) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].count(newElement) > 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].only(null);
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"])(newElement) ? newElement.props.children : null;
                } else {
                    return child;
                }
            });
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
                ...slotProps,
                ref: forwardedRef,
                children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"])(newElement) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneElement"])(newElement, void 0, newChildren) : null
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children
        });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
    const SlotClone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"])(children)) {
            const childrenRef = getElementRef(children);
            const props2 = mergeProps(slotProps, children.props);
            if (children.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"]) {
                props2.ref = forwardedRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["composeRefs"])(forwardedRef, childrenRef) : childrenRef;
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneElement"])(children, props2);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].count(children) > 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
    const Slottable2 = ({ children })=>{
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"], {
            children
        });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
}
var Slottable = /* @__PURE__ */ createSlottable("Slottable");
function isSlottable(child) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"])(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
            if (slotPropValue && childPropValue) {
                overrideProps[propName] = (...args)=>{
                    childPropValue(...args);
                    slotPropValue(...args);
                };
            } else if (slotPropValue) {
                overrideProps[propName] = slotPropValue;
            }
        } else if (propName === "style") {
            overrideProps[propName] = {
                ...slotPropValue,
                ...childPropValue
            };
        } else if (propName === "className") {
            overrideProps[propName] = [
                slotPropValue,
                childPropValue
            ].filter(Boolean).join(" ");
        }
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.props.ref;
    }
    return element.props.ref || element.ref;
}
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/class-variance-authority/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Copyright 2022 Joe Bell. All rights reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */ __turbopack_context__.s({
    "cva": (()=>cva),
    "cx": (()=>cx)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)");
;
const falsyToString = (value)=>typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clsx"];
const cva = (base, config)=>(props)=>{
        var _config_compoundVariants;
        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
        const { variants, defaultVariants } = config;
        const getVariantClassNames = Object.keys(variants).map((variant)=>{
            const variantProp = props === null || props === void 0 ? void 0 : props[variant];
            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
            if (variantProp === null) return null;
            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
            return variants[variant][variantKey];
        });
        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{
            let [key, value] = param;
            if (value === undefined) {
                return acc;
            }
            acc[key] = value;
            return acc;
        }, {});
        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param)=>{
            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
            return Object.entries(compoundVariantOptions).every((param)=>{
                let [key, value] = param;
                return Array.isArray(value) ? value.includes({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                }[key]) : ({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                })[key] === value;
            }) ? [
                ...acc,
                cvClass,
                cvClassName
            ] : acc;
        }, []);
        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    };
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-right.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.488.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>ArrowRight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M5 12h14",
            key: "1ays0h"
        }
    ],
    [
        "path",
        {
            d: "m12 5 7 7-7 7",
            key: "xquz4c"
        }
    ]
];
const ArrowRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("arrow-right", __iconNode);
;
 //# sourceMappingURL=arrow-right.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-right.js [app-ssr] (ecmascript) <export default as ArrowRight>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ArrowRight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$right$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$right$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/arrow-right.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/monitor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.488.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>Monitor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "rect",
        {
            width: "20",
            height: "14",
            x: "2",
            y: "3",
            rx: "2",
            key: "48i651"
        }
    ],
    [
        "line",
        {
            x1: "8",
            x2: "16",
            y1: "21",
            y2: "21",
            key: "1svkeh"
        }
    ],
    [
        "line",
        {
            x1: "12",
            x2: "12",
            y1: "17",
            y2: "21",
            key: "vw1qmm"
        }
    ]
];
const Monitor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("monitor", __iconNode);
;
 //# sourceMappingURL=monitor.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/monitor.js [app-ssr] (ecmascript) <export default as Monitor>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Monitor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$monitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$monitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/monitor.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/video.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.488.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>Video)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
            key: "ftymec"
        }
    ],
    [
        "rect",
        {
            x: "2",
            y: "6",
            width: "14",
            height: "12",
            rx: "2",
            key: "158x01"
        }
    ]
];
const Video = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("video", __iconNode);
;
 //# sourceMappingURL=video.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/video.js [app-ssr] (ecmascript) <export default as Video>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Video": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$video$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$video$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/video.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/layers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.488.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>Layers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
            key: "zw3jo"
        }
    ],
    [
        "path",
        {
            d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
            key: "1wduqc"
        }
    ],
    [
        "path",
        {
            d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
            key: "kqbvx6"
        }
    ]
];
const Layers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("layers", __iconNode);
;
 //# sourceMappingURL=layers.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/layers.js [app-ssr] (ecmascript) <export default as Layers>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Layers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$layers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$layers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/layers.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/grid-3x3.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.488.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>Grid3x3)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "rect",
        {
            width: "18",
            height: "18",
            x: "3",
            y: "3",
            rx: "2",
            key: "afitv7"
        }
    ],
    [
        "path",
        {
            d: "M3 9h18",
            key: "1pudct"
        }
    ],
    [
        "path",
        {
            d: "M3 15h18",
            key: "5xshup"
        }
    ],
    [
        "path",
        {
            d: "M9 3v18",
            key: "fh3hqa"
        }
    ],
    [
        "path",
        {
            d: "M15 3v18",
            key: "14nvp0"
        }
    ]
];
const Grid3x3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("grid-3x3", __iconNode);
;
 //# sourceMappingURL=grid-3x3.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/grid-3x3.js [app-ssr] (ecmascript) <export default as Grid>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Grid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$grid$2d$3x3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$grid$2d$3x3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/grid-3x3.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/eye.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.488.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>Eye)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
            key: "1nclc0"
        }
    ],
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "3",
            key: "1v7zrd"
        }
    ]
];
const Eye = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("eye", __iconNode);
;
 //# sourceMappingURL=eye.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/eye.js [app-ssr] (ecmascript) <export default as Eye>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Eye": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$eye$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$eye$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/eye.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/aperture.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.488.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>Aperture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "10",
            key: "1mglay"
        }
    ],
    [
        "path",
        {
            d: "m14.31 8 5.74 9.94",
            key: "1y6ab4"
        }
    ],
    [
        "path",
        {
            d: "M9.69 8h11.48",
            key: "1wxppr"
        }
    ],
    [
        "path",
        {
            d: "m7.38 12 5.74-9.94",
            key: "1grp0k"
        }
    ],
    [
        "path",
        {
            d: "M9.69 16 3.95 6.06",
            key: "libnyf"
        }
    ],
    [
        "path",
        {
            d: "M14.31 16H2.83",
            key: "x5fava"
        }
    ],
    [
        "path",
        {
            d: "m16.62 12-5.74 9.94",
            key: "1vwawt"
        }
    ]
];
const Aperture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("aperture", __iconNode);
;
 //# sourceMappingURL=aperture.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/aperture.js [app-ssr] (ecmascript) <export default as Aperture>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Aperture": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$aperture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$aperture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/aperture.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/wkt-parser/PROJJSONBuilderBase.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
class PROJJSONBuilderBase {
    static getId(node) {
        const idNode = node.find((child)=>Array.isArray(child) && child[0] === 'ID');
        if (idNode && idNode.length >= 3) {
            return {
                authority: idNode[1],
                code: parseInt(idNode[2], 10)
            };
        }
        return null;
    }
    static convertUnit(node, type = 'unit') {
        if (!node || node.length < 3) {
            return {
                type,
                name: 'unknown',
                conversion_factor: null
            };
        }
        const name = node[1];
        const conversionFactor = parseFloat(node[2]) || null;
        const idNode = node.find((child)=>Array.isArray(child) && child[0] === 'ID');
        const id = idNode ? {
            authority: idNode[1],
            code: parseInt(idNode[2], 10)
        } : null;
        return {
            type,
            name,
            conversion_factor: conversionFactor,
            id
        };
    }
    static convertAxis(node) {
        const name = node[1] || 'Unknown';
        // Determine the direction
        let direction;
        const abbreviationMatch = name.match(/^\((.)\)$/); // Match abbreviations like "(E)" or "(N)"
        if (abbreviationMatch) {
            // Use the abbreviation to determine the direction
            const abbreviation = abbreviationMatch[1].toUpperCase();
            if (abbreviation === 'E') direction = 'east';
            else if (abbreviation === 'N') direction = 'north';
            else if (abbreviation === 'U') direction = 'up';
            else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);
        } else {
            // Use the explicit direction provided in the AXIS node
            direction = node[2] ? node[2].toLowerCase() : 'unknown';
        }
        const orderNode = node.find((child)=>Array.isArray(child) && child[0] === 'ORDER');
        const order = orderNode ? parseInt(orderNode[1], 10) : null;
        const unitNode = node.find((child)=>Array.isArray(child) && (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT'));
        const unit = this.convertUnit(unitNode);
        return {
            name,
            direction,
            unit,
            order
        };
    }
    static extractAxes(node) {
        return node.filter((child)=>Array.isArray(child) && child[0] === 'AXIS').map((axis)=>this.convertAxis(axis)).sort((a, b)=>(a.order || 0) - (b.order || 0)); // Sort by the "order" property
    }
    static convert(node, result = {}) {
        switch(node[0]){
            case 'PROJCRS':
                result.type = 'ProjectedCRS';
                result.name = node[1];
                result.base_crs = node.find((child)=>Array.isArray(child) && child[0] === 'BASEGEOGCRS') ? this.convert(node.find((child)=>Array.isArray(child) && child[0] === 'BASEGEOGCRS')) : null;
                result.conversion = node.find((child)=>Array.isArray(child) && child[0] === 'CONVERSION') ? this.convert(node.find((child)=>Array.isArray(child) && child[0] === 'CONVERSION')) : null;
                const csNode = node.find((child)=>Array.isArray(child) && child[0] === 'CS');
                if (csNode) {
                    result.coordinate_system = {
                        type: csNode[1],
                        axis: this.extractAxes(node)
                    };
                }
                const lengthUnitNode = node.find((child)=>Array.isArray(child) && child[0] === 'LENGTHUNIT');
                if (lengthUnitNode) {
                    const unit = this.convertUnit(lengthUnitNode);
                    result.coordinate_system.unit = unit; // Add unit to coordinate_system
                }
                result.id = this.getId(node);
                break;
            case 'BASEGEOGCRS':
            case 'GEOGCRS':
                result.type = 'GeographicCRS';
                result.name = node[1];
                // Handle DATUM or ENSEMBLE
                const datumOrEnsembleNode = node.find((child)=>Array.isArray(child) && (child[0] === 'DATUM' || child[0] === 'ENSEMBLE'));
                if (datumOrEnsembleNode) {
                    const datumOrEnsemble = this.convert(datumOrEnsembleNode);
                    if (datumOrEnsembleNode[0] === 'ENSEMBLE') {
                        result.datum_ensemble = datumOrEnsemble;
                    } else {
                        result.datum = datumOrEnsemble;
                    }
                    const primem = node.find((child)=>Array.isArray(child) && child[0] === 'PRIMEM');
                    if (primem && primem[1] !== 'Greenwich') {
                        datumOrEnsemble.prime_meridian = {
                            name: primem[1],
                            longitude: parseFloat(primem[2])
                        };
                    }
                }
                result.coordinate_system = {
                    type: 'ellipsoidal',
                    axis: this.extractAxes(node)
                };
                result.id = this.getId(node);
                break;
            case 'DATUM':
                result.type = 'GeodeticReferenceFrame';
                result.name = node[1];
                result.ellipsoid = node.find((child)=>Array.isArray(child) && child[0] === 'ELLIPSOID') ? this.convert(node.find((child)=>Array.isArray(child) && child[0] === 'ELLIPSOID')) : null;
                break;
            case 'ENSEMBLE':
                result.type = 'DatumEnsemble';
                result.name = node[1];
                // Extract ensemble members
                result.members = node.filter((child)=>Array.isArray(child) && child[0] === 'MEMBER').map((member)=>({
                        type: 'DatumEnsembleMember',
                        name: member[1],
                        id: this.getId(member)
                    }));
                // Extract accuracy
                const accuracyNode = node.find((child)=>Array.isArray(child) && child[0] === 'ENSEMBLEACCURACY');
                if (accuracyNode) {
                    result.accuracy = parseFloat(accuracyNode[1]);
                }
                // Extract ellipsoid
                const ellipsoidNode = node.find((child)=>Array.isArray(child) && child[0] === 'ELLIPSOID');
                if (ellipsoidNode) {
                    result.ellipsoid = this.convert(ellipsoidNode); // Convert the ellipsoid node
                }
                // Extract identifier for the ensemble
                result.id = this.getId(node);
                break;
            case 'ELLIPSOID':
                result.type = 'Ellipsoid';
                result.name = node[1];
                result.semi_major_axis = parseFloat(node[2]);
                result.inverse_flattening = parseFloat(node[3]);
                const units = node.find((child)=>Array.isArray(child) && child[0] === 'LENGTHUNIT') ? this.convert(node.find((child)=>Array.isArray(child) && child[0] === 'LENGTHUNIT'), result) : null;
                break;
            case 'CONVERSION':
                result.type = 'Conversion';
                result.name = node[1];
                result.method = node.find((child)=>Array.isArray(child) && child[0] === 'METHOD') ? this.convert(node.find((child)=>Array.isArray(child) && child[0] === 'METHOD')) : null;
                result.parameters = node.filter((child)=>Array.isArray(child) && child[0] === 'PARAMETER').map((param)=>this.convert(param));
                break;
            case 'METHOD':
                result.type = 'Method';
                result.name = node[1];
                result.id = this.getId(node);
                break;
            case 'PARAMETER':
                result.type = 'Parameter';
                result.name = node[1];
                result.value = parseFloat(node[2]);
                result.unit = this.convertUnit(node.find((child)=>Array.isArray(child) && (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT')));
                result.id = this.getId(node);
                break;
            case 'BOUNDCRS':
                result.type = 'BoundCRS';
                // Process SOURCECRS
                const sourceCrsNode = node.find((child)=>Array.isArray(child) && child[0] === 'SOURCECRS');
                if (sourceCrsNode) {
                    const sourceCrsContent = sourceCrsNode.find((child)=>Array.isArray(child));
                    result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;
                }
                // Process TARGETCRS
                const targetCrsNode = node.find((child)=>Array.isArray(child) && child[0] === 'TARGETCRS');
                if (targetCrsNode) {
                    const targetCrsContent = targetCrsNode.find((child)=>Array.isArray(child));
                    result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;
                }
                // Process ABRIDGEDTRANSFORMATION
                const transformationNode = node.find((child)=>Array.isArray(child) && child[0] === 'ABRIDGEDTRANSFORMATION');
                if (transformationNode) {
                    result.transformation = this.convert(transformationNode);
                } else {
                    result.transformation = null;
                }
                break;
            case 'ABRIDGEDTRANSFORMATION':
                result.type = 'Transformation';
                result.name = node[1];
                result.method = node.find((child)=>Array.isArray(child) && child[0] === 'METHOD') ? this.convert(node.find((child)=>Array.isArray(child) && child[0] === 'METHOD')) : null;
                result.parameters = node.filter((child)=>Array.isArray(child) && (child[0] === 'PARAMETER' || child[0] === 'PARAMETERFILE')).map((param)=>{
                    if (param[0] === 'PARAMETER') {
                        return this.convert(param);
                    } else if (param[0] === 'PARAMETERFILE') {
                        return {
                            name: param[1],
                            value: param[2],
                            id: {
                                'authority': 'EPSG',
                                'code': 8656
                            }
                        };
                    }
                });
                // Adjust the Scale difference parameter if present
                if (result.parameters.length === 7) {
                    const scaleDifference = result.parameters[6];
                    if (scaleDifference.name === 'Scale difference') {
                        scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;
                    }
                }
                result.id = this.getId(node);
                break;
            case 'AXIS':
                if (!result.coordinate_system) {
                    result.coordinate_system = {
                        type: 'unspecified',
                        axis: []
                    };
                }
                result.coordinate_system.axis.push(this.convertAxis(node));
                break;
            case 'LENGTHUNIT':
                const unit = this.convertUnit(node, 'LinearUnit');
                if (result.coordinate_system && result.coordinate_system.axis) {
                    result.coordinate_system.axis.forEach((axis)=>{
                        if (!axis.unit) {
                            axis.unit = unit;
                        }
                    });
                }
                if (unit.conversion_factor && unit.conversion_factor !== 1) {
                    if (result.semi_major_axis) {
                        result.semi_major_axis = {
                            value: result.semi_major_axis,
                            unit
                        };
                    }
                }
                break;
            default:
                result.keyword = node[0];
                break;
        }
        return result;
    }
}
const __TURBOPACK__default__export__ = PROJJSONBuilderBase;
}}),
"[project]/node_modules/wkt-parser/PROJJSONBuilder2015.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilderBase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/PROJJSONBuilderBase.js [app-ssr] (ecmascript)");
;
class PROJJSONBuilder2015 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilderBase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    static convert(node, result = {}) {
        super.convert(node, result);
        // Skip `CS` and `USAGE` nodes for WKT2-2015
        if (result.coordinate_system && result.coordinate_system.subtype === 'Cartesian') {
            delete result.coordinate_system;
        }
        if (result.usage) {
            delete result.usage;
        }
        return result;
    }
}
const __TURBOPACK__default__export__ = PROJJSONBuilder2015;
}}),
"[project]/node_modules/wkt-parser/PROJJSONBuilder2019.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilderBase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/PROJJSONBuilderBase.js [app-ssr] (ecmascript)");
;
class PROJJSONBuilder2019 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilderBase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    static convert(node, result = {}) {
        super.convert(node, result);
        // Handle `CS` node for WKT2-2019
        const csNode = node.find((child)=>Array.isArray(child) && child[0] === 'CS');
        if (csNode) {
            result.coordinate_system = {
                subtype: csNode[1],
                axis: this.extractAxes(node)
            };
        }
        // Handle `USAGE` node for WKT2-2019
        const usageNode = node.find((child)=>Array.isArray(child) && child[0] === 'USAGE');
        if (usageNode) {
            const scope = usageNode.find((child)=>Array.isArray(child) && child[0] === 'SCOPE');
            const area = usageNode.find((child)=>Array.isArray(child) && child[0] === 'AREA');
            const bbox = usageNode.find((child)=>Array.isArray(child) && child[0] === 'BBOX');
            result.usage = {};
            if (scope) {
                result.usage.scope = scope[1];
            }
            if (area) {
                result.usage.area = area[1];
            }
            if (bbox) {
                result.usage.bbox = bbox.slice(1);
            }
        }
        return result;
    }
}
const __TURBOPACK__default__export__ = PROJJSONBuilder2019;
}}),
"[project]/node_modules/wkt-parser/buildPROJJSON.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "buildPROJJSON": (()=>buildPROJJSON)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilder2015$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/PROJJSONBuilder2015.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilder2019$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/PROJJSONBuilder2019.js [app-ssr] (ecmascript)");
;
;
/**
 * Detects the WKT2 version based on the structure of the WKT.
 * @param {Array} root The root WKT array node.
 * @returns {string} The detected version ("2015" or "2019").
 */ function detectWKT2Version(root) {
    // Check for WKT2-2019-specific nodes
    if (root.find((child)=>Array.isArray(child) && child[0] === 'USAGE')) {
        return '2019'; // `USAGE` is specific to WKT2-2019
    }
    // Check for WKT2-2015-specific nodes
    if (root.find((child)=>Array.isArray(child) && child[0] === 'CS')) {
        return '2015'; // `CS` is valid in both, but default to 2015 unless `USAGE` is present
    }
    if (root[0] === 'BOUNDCRS' || root[0] === 'PROJCRS' || root[0] === 'GEOGCRS') {
        return '2015'; // These are valid in both, but default to 2015
    }
    // Default to WKT2-2015 if no specific indicators are found
    return '2015';
}
function buildPROJJSON(root) {
    const version = detectWKT2Version(root);
    const builder = version === '2019' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilder2019$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$PROJJSONBuilder2015$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
    return builder.convert(root);
}
}}),
"[project]/node_modules/wkt-parser/detectWKTVersion.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Detects whether the WKT string is WKT1 or WKT2.
 * @param {string} wkt The WKT string.
 * @returns {string} The detected version ("WKT1" or "WKT2").
 */ __turbopack_context__.s({
    "detectWKTVersion": (()=>detectWKTVersion)
});
function detectWKTVersion(wkt) {
    // Normalize the WKT string for easier keyword matching
    const normalizedWKT = wkt.toUpperCase();
    // Check for WKT2-specific keywords
    if (normalizedWKT.includes('PROJCRS') || normalizedWKT.includes('GEOGCRS') || normalizedWKT.includes('BOUNDCRS') || normalizedWKT.includes('VERTCRS') || normalizedWKT.includes('LENGTHUNIT') || normalizedWKT.includes('ANGLEUNIT') || normalizedWKT.includes('SCALEUNIT')) {
        return 'WKT2';
    }
    // Check for WKT1-specific keywords
    if (normalizedWKT.includes('PROJCS') || normalizedWKT.includes('GEOGCS') || normalizedWKT.includes('LOCAL_CS') || normalizedWKT.includes('VERT_CS') || normalizedWKT.includes('UNIT')) {
        return 'WKT1';
    }
    // Default to WKT1 if no specific indicators are found
    return 'WKT1';
}
}}),
"[project]/node_modules/wkt-parser/parser.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = parseString;
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
    if (typeof text !== 'string') {
        throw new Error('not a string');
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
    var char = this.text[this.place++];
    if (this.state !== QUOTED) {
        while(whitespace.test(char)){
            if (this.place >= this.text.length) {
                return;
            }
            char = this.text[this.place++];
        }
    }
    switch(this.state){
        case NEUTRAL:
            return this.neutral(char);
        case KEYWORD:
            return this.keyword(char);
        case QUOTED:
            return this.quoted(char);
        case AFTERQUOTE:
            return this.afterquote(char);
        case NUMBER:
            return this.number(char);
        case ENDED:
            return;
    }
};
Parser.prototype.afterquote = function(char) {
    if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
    }
    if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
    if (char === ',') {
        if (this.word !== null) {
            this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
    }
    if (char === ']') {
        this.level--;
        if (this.word !== null) {
            this.currentObject.push(this.word);
            this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
            this.state = ENDED;
        }
        return;
    }
};
Parser.prototype.number = function(char) {
    if (digets.test(char)) {
        this.word += char;
        return;
    }
    if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
    if (char === '"') {
        this.state = AFTERQUOTE;
        return;
    }
    this.word += char;
    return;
};
Parser.prototype.keyword = function(char) {
    if (keyword.test(char)) {
        this.word += char;
        return;
    }
    if (char === '[') {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
            this.root = newObjects;
        } else {
            this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
    }
    if (endThings.test(char)) {
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
    if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
    }
    if (char === '"') {
        this.word = '';
        this.state = QUOTED;
        return;
    }
    if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
    }
    if (endThings.test(char)) {
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
    while(this.place < this.text.length){
        this.readCharicter();
    }
    if (this.state === ENDED) {
        return this.root;
    }
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
    var parser = new Parser(txt);
    return parser.output();
}
}}),
"[project]/node_modules/wkt-parser/process.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "sExpr": (()=>sExpr)
});
function mapit(obj, key, value) {
    if (Array.isArray(key)) {
        value.unshift(key);
        key = null;
    }
    var thing = key ? {} : obj;
    var out = value.reduce(function(newObj, item) {
        sExpr(item, newObj);
        return newObj;
    }, thing);
    if (key) {
        obj[key] = out;
    }
}
function sExpr(v, obj) {
    if (!Array.isArray(v)) {
        obj[v] = true;
        return;
    }
    var key = v.shift();
    if (key === 'PARAMETER') {
        key = v.shift();
    }
    if (v.length === 1) {
        if (Array.isArray(v[0])) {
            obj[key] = {};
            sExpr(v[0], obj[key]);
            return;
        }
        obj[key] = v[0];
        return;
    }
    if (!v.length) {
        obj[key] = true;
        return;
    }
    if (key === 'TOWGS84') {
        obj[key] = v;
        return;
    }
    if (key === 'AXIS') {
        if (!(key in obj)) {
            obj[key] = [];
        }
        obj[key].push(v);
        return;
    }
    if (!Array.isArray(key)) {
        obj[key] = {};
    }
    var i;
    switch(key){
        case 'UNIT':
        case 'PRIMEM':
        case 'VERT_DATUM':
            obj[key] = {
                name: v[0].toLowerCase(),
                convert: v[1]
            };
            if (v.length === 3) {
                sExpr(v[2], obj[key]);
            }
            return;
        case 'SPHEROID':
        case 'ELLIPSOID':
            obj[key] = {
                name: v[0],
                a: v[1],
                rf: v[2]
            };
            if (v.length === 4) {
                sExpr(v[3], obj[key]);
            }
            return;
        case 'EDATUM':
        case 'ENGINEERINGDATUM':
        case 'LOCAL_DATUM':
        case 'DATUM':
        case 'VERT_CS':
        case 'VERTCRS':
        case 'VERTICALCRS':
            v[0] = [
                'name',
                v[0]
            ];
            mapit(obj, key, v);
            return;
        case 'COMPD_CS':
        case 'COMPOUNDCRS':
        case 'FITTED_CS':
        // the followings are the crs defined in
        // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
        case 'PROJECTEDCRS':
        case 'PROJCRS':
        case 'GEOGCS':
        case 'GEOCCS':
        case 'PROJCS':
        case 'LOCAL_CS':
        case 'GEODCRS':
        case 'GEODETICCRS':
        case 'GEODETICDATUM':
        case 'ENGCRS':
        case 'ENGINEERINGCRS':
            v[0] = [
                'name',
                v[0]
            ];
            mapit(obj, key, v);
            obj[key].type = key;
            return;
        default:
            i = -1;
            while(++i < v.length){
                if (!Array.isArray(v[i])) {
                    return sExpr(v, obj[key]);
                }
            }
            return mapit(obj, key, v);
    }
}
}}),
"[project]/node_modules/wkt-parser/util.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "applyProjectionDefaults": (()=>applyProjectionDefaults),
    "d2r": (()=>d2r)
});
var D2R = 0.01745329251994329577;
function d2r(input) {
    return input * D2R;
}
function applyProjectionDefaults(wkt) {
    // Normalize projName for WKT2 compatibility
    const normalizedProjName = (wkt.projName || '').toLowerCase().replace(/_/g, ' ');
    if (!wkt.long0 && wkt.longc && (normalizedProjName === 'albers conic equal area' || normalizedProjName === 'lambert azimuthal equal area')) {
        wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (normalizedProjName === 'stereographic south pole' || normalizedProjName === 'polar stereographic (variant b)')) {
        wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
        wkt.lat_ts = wkt.lat1;
        delete wkt.lat1;
    } else if (!wkt.lat_ts && wkt.lat0 && (normalizedProjName === 'polar stereographic' || normalizedProjName === 'polar stereographic (variant a)')) {
        wkt.lat_ts = wkt.lat0;
        wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
        delete wkt.lat1;
    }
}
}}),
"[project]/node_modules/wkt-parser/transformPROJJSON.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "transformPROJJSON": (()=>transformPROJJSON)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/util.js [app-ssr] (ecmascript)");
;
// Helper function to process units and to_meter
function processUnit(unit) {
    let result = {
        units: null,
        to_meter: undefined
    };
    if (typeof unit === 'string') {
        result.units = unit.toLowerCase();
        if (result.units === 'metre') {
            result.units = 'meter'; // Normalize 'metre' to 'meter'
        }
        if (result.units === 'meter') {
            result.to_meter = 1; // Only set to_meter if units are 'meter'
        }
    } else if (unit && unit.name) {
        result.units = unit.name.toLowerCase();
        if (result.units === 'metre') {
            result.units = 'meter'; // Normalize 'metre' to 'meter'
        }
        result.to_meter = unit.conversion_factor;
    }
    return result;
}
function toValue(valueOrObject) {
    if (typeof valueOrObject === 'object') {
        return valueOrObject.value * valueOrObject.unit.conversion_factor;
    }
    return valueOrObject;
}
function calculateEllipsoid(value, result) {
    if (value.ellipsoid.radius) {
        result.a = value.ellipsoid.radius;
        result.rf = 0;
    } else {
        result.a = toValue(value.ellipsoid.semi_major_axis);
        if (value.ellipsoid.inverse_flattening !== undefined) {
            result.rf = value.ellipsoid.inverse_flattening;
        } else if (value.ellipsoid.semi_major_axis !== undefined && value.ellipsoid.semi_minor_axis !== undefined) {
            result.rf = result.a / (result.a - toValue(value.ellipsoid.semi_minor_axis));
        }
    }
}
function transformPROJJSON(projjson, result = {}) {
    if (!projjson || typeof projjson !== 'object') {
        return projjson; // Return primitive values as-is
    }
    if (projjson.type === 'BoundCRS') {
        transformPROJJSON(projjson.source_crs, result);
        if (projjson.transformation) {
            if (projjson.transformation.method && projjson.transformation.method.name === 'NTv2') {
                // Set nadgrids to the filename from the parameterfile
                result.nadgrids = projjson.transformation.parameters[0].value;
            } else {
                // Populate datum_params if no parameterfile is found
                result.datum_params = projjson.transformation.parameters.map((param)=>param.value);
            }
        }
        return result; // Return early for BoundCRS
    }
    // Handle specific keys in PROJJSON
    Object.keys(projjson).forEach((key)=>{
        const value = projjson[key];
        if (value === null) {
            return;
        }
        switch(key){
            case 'name':
                if (result.srsCode) {
                    break;
                }
                result.name = value;
                result.srsCode = value; // Map `name` to `srsCode`
                break;
            case 'type':
                if (value === 'GeographicCRS') {
                    result.projName = 'longlat';
                } else if (value === 'ProjectedCRS' && projjson.conversion && projjson.conversion.method) {
                    result.projName = projjson.conversion.method.name; // Retain original capitalization
                }
                break;
            case 'datum':
            case 'datum_ensemble':
                if (value.ellipsoid) {
                    // Extract ellipsoid properties
                    result.ellps = value.ellipsoid.name;
                    calculateEllipsoid(value, result);
                }
                if (value.prime_meridian) {
                    result.from_greenwich = value.prime_meridian.longitude * Math.PI / 180; // Convert to radians
                }
                break;
            case 'ellipsoid':
                result.ellps = value.name;
                calculateEllipsoid(value, result);
                break;
            case 'prime_meridian':
                result.long0 = (value.longitude || 0) * Math.PI / 180; // Convert to radians
                break;
            case 'coordinate_system':
                if (value.axis) {
                    result.axis = value.axis.map((axis)=>{
                        const direction = axis.direction;
                        if (direction === 'east') return 'e';
                        if (direction === 'north') return 'n';
                        if (direction === 'west') return 'w';
                        if (direction === 'south') return 's';
                        throw new Error(`Unknown axis direction: ${direction}`);
                    }).join('') + 'u'; // Combine into a single string (e.g., "enu")
                    if (value.unit) {
                        const { units, to_meter } = processUnit(value.unit);
                        result.units = units;
                        result.to_meter = to_meter;
                    } else if (value.axis[0] && value.axis[0].unit) {
                        const { units, to_meter } = processUnit(value.axis[0].unit);
                        result.units = units;
                        result.to_meter = to_meter;
                    }
                }
                break;
            case 'id':
                if (value.authority && value.code) {
                    result.title = value.authority + ':' + value.code;
                }
                break;
            case 'conversion':
                if (value.method && value.method.name) {
                    result.projName = value.method.name; // Retain original capitalization
                }
                if (value.parameters) {
                    value.parameters.forEach((param)=>{
                        const paramName = param.name.toLowerCase().replace(/\s+/g, '_');
                        const paramValue = param.value;
                        if (param.unit && param.unit.conversion_factor) {
                            result[paramName] = paramValue * param.unit.conversion_factor; // Convert to radians or meters
                        } else if (param.unit === 'degree') {
                            result[paramName] = paramValue * Math.PI / 180; // Convert to radians
                        } else {
                            result[paramName] = paramValue;
                        }
                    });
                }
                break;
            case 'unit':
                if (value.name) {
                    result.units = value.name.toLowerCase();
                    if (result.units === 'metre') {
                        result.units = 'meter';
                    }
                }
                if (value.conversion_factor) {
                    result.to_meter = value.conversion_factor;
                }
                break;
            case 'base_crs':
                transformPROJJSON(value, result); // Pass `result` directly
                result.datumCode = value.id ? value.id.authority + '_' + value.id.code : value.name; // Set datumCode
                break;
            default:
                break;
        }
    });
    // Additional calculated properties
    if (result.latitude_of_false_origin !== undefined) {
        result.lat0 = result.latitude_of_false_origin; // Already in radians
    }
    if (result.longitude_of_false_origin !== undefined) {
        result.long0 = result.longitude_of_false_origin;
    }
    if (result.latitude_of_standard_parallel !== undefined) {
        result.lat0 = result.latitude_of_standard_parallel;
        result.lat1 = result.latitude_of_standard_parallel;
    }
    if (result.latitude_of_1st_standard_parallel !== undefined) {
        result.lat1 = result.latitude_of_1st_standard_parallel;
    }
    if (result.latitude_of_2nd_standard_parallel !== undefined) {
        result.lat2 = result.latitude_of_2nd_standard_parallel;
    }
    if (result.latitude_of_projection_centre !== undefined) {
        result.lat0 = result.latitude_of_projection_centre;
    }
    if (result.longitude_of_projection_centre !== undefined) {
        result.longc = result.longitude_of_projection_centre;
    }
    if (result.easting_at_false_origin !== undefined) {
        result.x0 = result.easting_at_false_origin;
    }
    if (result.northing_at_false_origin !== undefined) {
        result.y0 = result.northing_at_false_origin;
    }
    if (result.latitude_of_natural_origin !== undefined) {
        result.lat0 = result.latitude_of_natural_origin;
    }
    if (result.longitude_of_natural_origin !== undefined) {
        result.long0 = result.longitude_of_natural_origin;
    }
    if (result.longitude_of_origin !== undefined) {
        result.long0 = result.longitude_of_origin;
    }
    if (result.false_easting !== undefined) {
        result.x0 = result.false_easting;
    }
    if (result.easting_at_projection_centre) {
        result.x0 = result.easting_at_projection_centre;
    }
    if (result.false_northing !== undefined) {
        result.y0 = result.false_northing;
    }
    if (result.northing_at_projection_centre) {
        result.y0 = result.northing_at_projection_centre;
    }
    if (result.standard_parallel_1 !== undefined) {
        result.lat1 = result.standard_parallel_1;
    }
    if (result.standard_parallel_2 !== undefined) {
        result.lat2 = result.standard_parallel_2;
    }
    if (result.scale_factor_at_natural_origin !== undefined) {
        result.k0 = result.scale_factor_at_natural_origin;
    }
    if (result.scale_factor_at_projection_centre !== undefined) {
        result.k0 = result.scale_factor_at_projection_centre;
    }
    if (result.scale_factor_on_pseudo_standard_parallel !== undefined) {
        result.k0 = result.scale_factor_on_pseudo_standard_parallel;
    }
    if (result.azimuth !== undefined) {
        result.alpha = result.azimuth;
    }
    if (result.azimuth_at_projection_centre !== undefined) {
        result.alpha = result.azimuth_at_projection_centre;
    }
    if (result.angle_from_rectified_to_skew_grid) {
        result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;
    }
    // Apply projection defaults
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyProjectionDefaults"])(result);
    return result;
}
}}),
"[project]/node_modules/wkt-parser/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$buildPROJJSON$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/buildPROJJSON.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$detectWKTVersion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/detectWKTVersion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/parser.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$process$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/process.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$transformPROJJSON$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/transformPROJJSON.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wkt-parser/util.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
var knownTypes = [
    'PROJECTEDCRS',
    'PROJCRS',
    'GEOGCS',
    'GEOCCS',
    'PROJCS',
    'LOCAL_CS',
    'GEODCRS',
    'GEODETICCRS',
    'GEODETICDATUM',
    'ENGCRS',
    'ENGINEERINGCRS'
];
function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && inName in obj) {
        obj[outName] = obj[inName];
        if (params.length === 3) {
            obj[outName] = params[2](obj[outName]);
        }
    }
}
function cleanWKT(wkt) {
    var keys = Object.keys(wkt);
    for(var i = 0, ii = keys.length; i < ii; ++i){
        var key = keys[i];
        // the followings are the crs defined in
        // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
        if (knownTypes.indexOf(key) !== -1) {
            setPropertiesFromWkt(wkt[key]);
        }
        if (typeof wkt[key] === 'object') {
            cleanWKT(wkt[key]);
        }
    }
}
function setPropertiesFromWkt(wkt) {
    if (wkt.AUTHORITY) {
        var authority = Object.keys(wkt.AUTHORITY)[0];
        if (authority && authority in wkt.AUTHORITY) {
            wkt.title = authority + ':' + wkt.AUTHORITY[authority];
        }
    }
    if (wkt.type === 'GEOGCS') {
        wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
        wkt.projName = 'identity';
        wkt.local = true;
    } else {
        if (typeof wkt.PROJECTION === 'object') {
            wkt.projName = Object.keys(wkt.PROJECTION)[0];
        } else {
            wkt.projName = wkt.PROJECTION;
        }
    }
    if (wkt.AXIS) {
        var axisOrder = '';
        for(var i = 0, ii = wkt.AXIS.length; i < ii; ++i){
            var axis = [
                wkt.AXIS[i][0].toLowerCase(),
                wkt.AXIS[i][1].toLowerCase()
            ];
            if (axis[0].indexOf('north') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north') {
                axisOrder += 'n';
            } else if (axis[0].indexOf('south') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south') {
                axisOrder += 's';
            } else if (axis[0].indexOf('east') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east') {
                axisOrder += 'e';
            } else if (axis[0].indexOf('west') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west') {
                axisOrder += 'w';
            }
        }
        if (axisOrder.length === 2) {
            axisOrder += 'u';
        }
        if (axisOrder.length === 3) {
            wkt.axis = axisOrder;
        }
    }
    if (wkt.UNIT) {
        wkt.units = wkt.UNIT.name.toLowerCase();
        if (wkt.units === 'metre') {
            wkt.units = 'meter';
        }
        if (wkt.UNIT.convert) {
            if (wkt.type === 'GEOGCS') {
                if (wkt.DATUM && wkt.DATUM.SPHEROID) {
                    wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
                }
            } else {
                wkt.to_meter = wkt.UNIT.convert;
            }
        }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === 'GEOGCS') {
        geogcs = wkt;
    }
    if (geogcs) {
        //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
        //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
        //}
        if (geogcs.DATUM) {
            wkt.datumCode = geogcs.DATUM.name.toLowerCase();
        } else {
            wkt.datumCode = geogcs.name.toLowerCase();
        }
        if (wkt.datumCode.slice(0, 2) === 'd_') {
            wkt.datumCode = wkt.datumCode.slice(2);
        }
        if (wkt.datumCode === 'new_zealand_1949') {
            wkt.datumCode = 'nzgd49';
        }
        if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
            if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
                wkt.sphere = true;
            }
            wkt.datumCode = 'wgs84';
        }
        if (wkt.datumCode === 'belge_1972') {
            wkt.datumCode = 'rnb72';
        }
        if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
            wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
            if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
                wkt.ellps = 'intl';
            }
            wkt.a = geogcs.DATUM.SPHEROID.a;
            wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
        }
        if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
            wkt.datum_params = geogcs.DATUM.TOWGS84;
        }
        if (~wkt.datumCode.indexOf('osgb_1936')) {
            wkt.datumCode = 'osgb36';
        }
        if (~wkt.datumCode.indexOf('osni_1952')) {
            wkt.datumCode = 'osni52';
        }
        if (~wkt.datumCode.indexOf('tm65') || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
            wkt.datumCode = 'ire65';
        }
        if (wkt.datumCode === 'ch1903+') {
            wkt.datumCode = 'ch1903';
        }
        if (~wkt.datumCode.indexOf('israel')) {
            wkt.datumCode = 'isr93';
        }
    }
    if (wkt.b && !isFinite(wkt.b)) {
        wkt.b = wkt.a;
    }
    if (wkt.rectified_grid_angle) {
        wkt.rectified_grid_angle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"])(wkt.rectified_grid_angle);
    }
    function toMeter(input) {
        var ratio = wkt.to_meter || 1;
        return input * ratio;
    }
    var renamer = function(a) {
        return rename(wkt, a);
    };
    var list = [
        [
            'standard_parallel_1',
            'Standard_Parallel_1'
        ],
        [
            'standard_parallel_1',
            'Latitude of 1st standard parallel'
        ],
        [
            'standard_parallel_2',
            'Standard_Parallel_2'
        ],
        [
            'standard_parallel_2',
            'Latitude of 2nd standard parallel'
        ],
        [
            'false_easting',
            'False_Easting'
        ],
        [
            'false_easting',
            'False easting'
        ],
        [
            'false-easting',
            'Easting at false origin'
        ],
        [
            'false_northing',
            'False_Northing'
        ],
        [
            'false_northing',
            'False northing'
        ],
        [
            'false_northing',
            'Northing at false origin'
        ],
        [
            'central_meridian',
            'Central_Meridian'
        ],
        [
            'central_meridian',
            'Longitude of natural origin'
        ],
        [
            'central_meridian',
            'Longitude of false origin'
        ],
        [
            'latitude_of_origin',
            'Latitude_Of_Origin'
        ],
        [
            'latitude_of_origin',
            'Central_Parallel'
        ],
        [
            'latitude_of_origin',
            'Latitude of natural origin'
        ],
        [
            'latitude_of_origin',
            'Latitude of false origin'
        ],
        [
            'scale_factor',
            'Scale_Factor'
        ],
        [
            'k0',
            'scale_factor'
        ],
        [
            'latitude_of_center',
            'Latitude_Of_Center'
        ],
        [
            'latitude_of_center',
            'Latitude_of_center'
        ],
        [
            'lat0',
            'latitude_of_center',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'longitude_of_center',
            'Longitude_Of_Center'
        ],
        [
            'longitude_of_center',
            'Longitude_of_center'
        ],
        [
            'longc',
            'longitude_of_center',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'x0',
            'false_easting',
            toMeter
        ],
        [
            'y0',
            'false_northing',
            toMeter
        ],
        [
            'long0',
            'central_meridian',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'lat0',
            'latitude_of_origin',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'lat0',
            'standard_parallel_1',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'lat1',
            'standard_parallel_1',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'lat2',
            'standard_parallel_2',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'azimuth',
            'Azimuth'
        ],
        [
            'alpha',
            'azimuth',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d2r"]
        ],
        [
            'srsCode',
            'name'
        ]
    ];
    list.forEach(renamer);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyProjectionDefaults"])(wkt);
}
function __TURBOPACK__default__export__(wkt) {
    if (typeof wkt === 'object') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$transformPROJJSON$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformPROJJSON"])(wkt);
    }
    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$detectWKTVersion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["detectWKTVersion"])(wkt);
    var lisp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(wkt);
    if (version === 'WKT2') {
        const projjson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$buildPROJJSON$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildPROJJSON"])(lisp);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$transformPROJJSON$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformPROJJSON"])(projjson);
    }
    var type = lisp[0];
    var obj = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$process$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sExpr"])(lisp, obj);
    cleanWKT(obj);
    return obj[type];
}
}}),
"[project]/node_modules/mgrs/mgrs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "forward": (()=>forward),
    "inverse": (()=>inverse),
    "toPoint": (()=>toPoint)
});
var NUM_100K_SETS = 6;
/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */ var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */ var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z
const __TURBOPACK__default__export__ = {
    forward: forward,
    inverse: inverse,
    toPoint: toPoint
};
function forward(ll, accuracy) {
    accuracy = accuracy || 5; // default accuracy 1m
    return encode(LLtoUTM({
        lat: ll[1],
        lon: ll[0]
    }), accuracy);
}
;
function inverse(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
        return [
            bbox.lon,
            bbox.lat,
            bbox.lon,
            bbox.lat
        ];
    }
    return [
        bbox.left,
        bbox.bottom,
        bbox.right,
        bbox.top
    ];
}
;
function toPoint(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
        return [
            bbox.lon,
            bbox.lat
        ];
    }
    return [
        (bbox.left + bbox.right) / 2,
        (bbox.top + bbox.bottom) / 2
    ];
}
;
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */ function degToRad(deg) {
    return deg * (Math.PI / 180.0);
}
/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */ function radToDeg(rad) {
    return 180.0 * (rad / Math.PI);
}
/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */ function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    // (int)
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;
    //Make sure the longitude 180.00 is in Zone 60
    if (Long === 180) {
        ZoneNumber = 60;
    }
    // Special zone for Norway
    if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
        ZoneNumber = 32;
    }
    // Special zones for Svalbard
    if (Lat >= 72.0 && Lat < 84.0) {
        if (Long >= 0.0 && Long < 9.0) {
            ZoneNumber = 31;
        } else if (Long >= 9.0 && Long < 21.0) {
            ZoneNumber = 33;
        } else if (Long >= 21.0 && Long < 33.0) {
            ZoneNumber = 35;
        } else if (Long >= 33.0 && Long < 42.0) {
            ZoneNumber = 37;
        }
    }
    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
    // in middle of
    // zone
    LongOriginRad = degToRad(LongOrigin);
    eccPrimeSquared = eccSquared / (1 - eccSquared);
    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A = Math.cos(LatRad) * (LongRad - LongOriginRad);
    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
    var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;
    var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));
    if (Lat < 0.0) {
        UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
    }
    return {
        northing: Math.round(UTMNorthing),
        easting: Math.round(UTMEasting),
        zoneNumber: ZoneNumber,
        zoneLetter: getLetterDesignator(Lat)
    };
}
/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */ function UTMtoLL(utm) {
    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    // check the ZoneNummber is valid
    if (zoneNumber < 0 || zoneNumber > 60) {
        return null;
    }
    var k0 = 0.9996;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C1, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;
    // remove 500,000 meter offset for longitude
    var x = UTMEasting - 500000.0;
    var y = UTMNorthing;
    // We must know somehow if we are in the Northern or Southern
    // hemisphere, this is the only time we use the letter So even
    // if the Zone letter isn't exactly correct it should indicate
    // the hemisphere correctly
    if (zoneLetter < 'N') {
        y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
    }
    // There are 60 zones with zone 1 being at West -180 to -174
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
    // in middle of
    // zone
    eccPrimeSquared = eccSquared / (1 - eccSquared);
    M = y / k0;
    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
    // double phi1 = ProjMath.radToDeg(phi1Rad);
    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x / (N1 * k0);
    var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);
    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);
    var result;
    if (utm.accuracy) {
        var topRight = UTMtoLL({
            northing: utm.northing + utm.accuracy,
            easting: utm.easting + utm.accuracy,
            zoneLetter: utm.zoneLetter,
            zoneNumber: utm.zoneNumber
        });
        result = {
            top: topRight.lat,
            right: topRight.lon,
            bottom: lat,
            left: lon
        };
    } else {
        result = {
            lat: lat,
            lon: lon
        };
    }
    return result;
}
/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */ function getLetterDesignator(lat) {
    //This is here as an error flag to show that the Latitude is
    //outside MGRS limits
    var LetterDesignator = 'Z';
    if (84 >= lat && lat >= 72) {
        LetterDesignator = 'X';
    } else if (72 > lat && lat >= 64) {
        LetterDesignator = 'W';
    } else if (64 > lat && lat >= 56) {
        LetterDesignator = 'V';
    } else if (56 > lat && lat >= 48) {
        LetterDesignator = 'U';
    } else if (48 > lat && lat >= 40) {
        LetterDesignator = 'T';
    } else if (40 > lat && lat >= 32) {
        LetterDesignator = 'S';
    } else if (32 > lat && lat >= 24) {
        LetterDesignator = 'R';
    } else if (24 > lat && lat >= 16) {
        LetterDesignator = 'Q';
    } else if (16 > lat && lat >= 8) {
        LetterDesignator = 'P';
    } else if (8 > lat && lat >= 0) {
        LetterDesignator = 'N';
    } else if (0 > lat && lat >= -8) {
        LetterDesignator = 'M';
    } else if (-8 > lat && lat >= -16) {
        LetterDesignator = 'L';
    } else if (-16 > lat && lat >= -24) {
        LetterDesignator = 'K';
    } else if (-24 > lat && lat >= -32) {
        LetterDesignator = 'J';
    } else if (-32 > lat && lat >= -40) {
        LetterDesignator = 'H';
    } else if (-40 > lat && lat >= -48) {
        LetterDesignator = 'G';
    } else if (-48 > lat && lat >= -56) {
        LetterDesignator = 'F';
    } else if (-56 > lat && lat >= -64) {
        LetterDesignator = 'E';
    } else if (-64 > lat && lat >= -72) {
        LetterDesignator = 'D';
    } else if (-72 > lat && lat >= -80) {
        LetterDesignator = 'C';
    }
    return LetterDesignator;
}
/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */ function encode(utm, accuracy) {
    // prepend with leading zeroes
    var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */ function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 100000);
    var setRow = Math.floor(northing / 100000) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
}
/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */ function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
        setParm = NUM_100K_SETS;
    }
    return setParm;
}
/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */ function getLetter100kID(column, row, parm) {
    // colOrigin and rowOrigin are the letters at the origin of the set
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
    // colInt and rowInt are the letters to build to return
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;
    if (colInt > Z) {
        colInt = colInt - Z + A - 1;
        rollover = true;
    }
    if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
        colInt++;
    }
    if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
        colInt++;
        if (colInt === I) {
            colInt++;
        }
    }
    if (colInt > Z) {
        colInt = colInt - Z + A - 1;
    }
    if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
        rollover = true;
    } else {
        rollover = false;
    }
    if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
        rowInt++;
    }
    if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
        rowInt++;
        if (rowInt === I) {
            rowInt++;
        }
    }
    if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
    }
    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
}
/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */ function decode(mgrsString) {
    if (mgrsString && mgrsString.length === 0) {
        throw "MGRSPoint coverting from nothing";
    }
    var length = mgrsString.length;
    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;
    // get Zone number
    while(!/[A-Z]/.test(testChar = mgrsString.charAt(i))){
        if (i >= 2) {
            throw "MGRSPoint bad conversion from: " + mgrsString;
        }
        sb += testChar;
        i++;
    }
    var zoneNumber = parseInt(sb, 10);
    if (i === 0 || i + 3 > length) {
        // A good MGRS string has to be 4-5 digits long,
        // ##AAA/#AAA at least.
        throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    var zoneLetter = mgrsString.charAt(i++);
    // Should we check the zone letter here? Why not.
    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
        throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
    }
    hunK = mgrsString.substring(i, i += 2);
    var set = get100kSetForZone(zoneNumber);
    var east100k = getEastingFromChar(hunK.charAt(0), set);
    var north100k = getNorthingFromChar(hunK.charAt(1), set);
    // We have a bug where the northing may be 2000000 too low.
    // How
    // do we know when to roll over?
    while(north100k < getMinNorthing(zoneLetter)){
        north100k += 2000000;
    }
    // calculate the char index for easting/northing separator
    var remainder = length - i;
    if (remainder % 2 !== 0) {
        throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
    }
    var sep = remainder / 2;
    var sepEasting = 0.0;
    var sepNorthing = 0.0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
        accuracyBonus = 100000.0 / Math.pow(10, sep);
        sepEastingString = mgrsString.substring(i, i + sep);
        sepEasting = parseFloat(sepEastingString) * accuracyBonus;
        sepNorthingString = mgrsString.substring(i + sep);
        sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }
    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;
    return {
        easting: easting,
        northing: northing,
        zoneLetter: zoneLetter,
        zoneNumber: zoneNumber,
        accuracy: accuracyBonus
    };
}
/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */ function getEastingFromChar(e, set) {
    // colOrigin is the letter at the origin of the set for the
    // column
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
    var eastingValue = 100000.0;
    var rewindMarker = false;
    while(curCol !== e.charCodeAt(0)){
        curCol++;
        if (curCol === I) {
            curCol++;
        }
        if (curCol === O) {
            curCol++;
        }
        if (curCol > Z) {
            if (rewindMarker) {
                throw "Bad character: " + e;
            }
            curCol = A;
            rewindMarker = true;
        }
        eastingValue += 100000.0;
    }
    return eastingValue;
}
/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */ function getNorthingFromChar(n, set) {
    if (n > 'V') {
        throw "MGRSPoint given invalid Northing " + n;
    }
    // rowOrigin is the letter at the origin of the set for the
    // column
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
    var northingValue = 0.0;
    var rewindMarker = false;
    while(curRow !== n.charCodeAt(0)){
        curRow++;
        if (curRow === I) {
            curRow++;
        }
        if (curRow === O) {
            curRow++;
        }
        // fixing a bug making whole application hang in this loop
        // when 'n' is a wrong character
        if (curRow > V) {
            if (rewindMarker) {
                throw "Bad character: " + n;
            }
            curRow = A;
            rewindMarker = true;
        }
        northingValue += 100000.0;
    }
    return northingValue;
}
/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */ function getMinNorthing(zoneLetter) {
    var northing;
    switch(zoneLetter){
        case 'C':
            northing = 1100000.0;
            break;
        case 'D':
            northing = 2000000.0;
            break;
        case 'E':
            northing = 2800000.0;
            break;
        case 'F':
            northing = 3700000.0;
            break;
        case 'G':
            northing = 4600000.0;
            break;
        case 'H':
            northing = 5500000.0;
            break;
        case 'J':
            northing = 6400000.0;
            break;
        case 'K':
            northing = 7300000.0;
            break;
        case 'L':
            northing = 8200000.0;
            break;
        case 'M':
            northing = 9100000.0;
            break;
        case 'N':
            northing = 0.0;
            break;
        case 'P':
            northing = 800000.0;
            break;
        case 'Q':
            northing = 1700000.0;
            break;
        case 'R':
            northing = 2600000.0;
            break;
        case 'S':
            northing = 3500000.0;
            break;
        case 'T':
            northing = 4400000.0;
            break;
        case 'U':
            northing = 5300000.0;
            break;
        case 'V':
            northing = 6200000.0;
            break;
        case 'W':
            northing = 7000000.0;
            break;
        case 'X':
            northing = 7900000.0;
            break;
        default:
            northing = -1.0;
    }
    if (northing >= 0.0) {
        return northing;
    } else {
        throw "Invalid zone letter: " + zoneLetter;
    }
}
}}),
"[project]/node_modules/geographiclib-geodesic/geographiclib-geodesic.min.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(cb) {
    var geodesic = {};
    geodesic.Constants = {};
    geodesic.Math = {};
    geodesic.Accumulator = {};
    (function(c) {
        "use strict";
        c.WGS84 = {
            a: 6378137,
            f: 1 / 298.257223563
        };
        c.version = {
            major: 2,
            minor: 1,
            patch: 1
        };
        c.version_string = "2.1.1";
    })(geodesic.Constants);
    (function(m) {
        "use strict";
        m.digits = 53;
        m.epsilon = Math.pow(0.5, m.digits - 1);
        m.degree = Math.PI / 180;
        m.sq = function(x) {
            return x * x;
        };
        m.hypot = function(x, y) {
            return Math.sqrt(x * x + y * y);
        };
        m.cbrt = Math.cbrt || function(x) {
            var y = Math.pow(Math.abs(x), 1 / 3);
            return x > 0 ? y : x < 0 ? -y : x;
        };
        m.log1p = Math.log1p || function(x) {
            var y = 1 + x, z = y - 1;
            return z === 0 ? x : x * Math.log(y) / z;
        };
        m.atanh = Math.atanh || function(x) {
            var y = Math.abs(x);
            y = m.log1p(2 * y / (1 - y)) / 2;
            return x > 0 ? y : x < 0 ? -y : x;
        };
        m.copysign = function(x, y) {
            return Math.abs(x) * (y < 0 || y === 0 && 1 / y < 0 ? -1 : 1);
        };
        m.sum = function(u, v) {
            var s = u + v, up = s - v, vpp = s - up, t;
            up -= u;
            vpp -= v;
            t = s ? 0 - (up + vpp) : s;
            return {
                s: s,
                t: t
            };
        };
        m.polyval = function(N, p, s, x) {
            var y = N < 0 ? 0 : p[s++];
            while(--N >= 0)y = y * x + p[s++];
            return y;
        };
        m.AngRound = function(x) {
            var z = 1 / 16, y = Math.abs(x);
            y = y < z ? z - (z - y) : y;
            return m.copysign(y, x);
        };
        m.remainder = function(x, y) {
            x %= y;
            return x < -y / 2 ? x + y : x < y / 2 ? x : x - y;
        };
        m.AngNormalize = function(x) {
            var y = m.remainder(x, 360);
            return Math.abs(y) === 180 ? m.copysign(180, x) : y;
        };
        m.LatFix = function(x) {
            return Math.abs(x) > 90 ? NaN : x;
        };
        m.AngDiff = function(x, y) {
            var r = m.sum(m.remainder(-x, 360), m.remainder(y, 360)), d, e;
            r = m.sum(m.remainder(r.s, 360), r.t);
            d = r.s;
            e = r.t;
            if (d === 0 || Math.abs(d) === 180) d = m.copysign(d, e === 0 ? y - x : -e);
            return {
                d: d,
                e: e
            };
        };
        m.sincosd = function(x) {
            var d, r, q, s, c, sinx, cosx;
            d = x % 360;
            q = Math.round(d / 90);
            d -= 90 * q;
            r = d * this.degree;
            s = Math.sin(r);
            c = Math.cos(r);
            if (Math.abs(d) === 45) {
                c = Math.sqrt(0.5);
                s = m.copysign(c, r);
            } else if (Math.abs(d) === 30) {
                c = Math.sqrt(0.75);
                s = m.copysign(0.5, r);
            }
            switch(q & 3){
                case 0:
                    sinx = s;
                    cosx = c;
                    break;
                case 1:
                    sinx = c;
                    cosx = -s;
                    break;
                case 2:
                    sinx = -s;
                    cosx = -c;
                    break;
                default:
                    sinx = -c;
                    cosx = s;
                    break;
            }
            cosx += 0;
            if (sinx === 0) sinx = m.copysign(sinx, x);
            return {
                s: sinx,
                c: cosx
            };
        };
        m.sincosde = function(x, t) {
            var d, r, q, s, c, sinx, cosx;
            d = x % 360;
            q = Math.round(d / 90);
            d = m.AngRound(d - 90 * q + t);
            r = d * this.degree;
            s = Math.sin(r);
            c = Math.cos(r);
            if (Math.abs(d) === 45) {
                c = Math.sqrt(0.5);
                s = m.copysign(c, r);
            } else if (Math.abs(d) === 30) {
                c = Math.sqrt(0.75);
                s = m.copysign(0.5, r);
            }
            switch(q & 3){
                case 0:
                    sinx = s;
                    cosx = c;
                    break;
                case 1:
                    sinx = c;
                    cosx = -s;
                    break;
                case 2:
                    sinx = -s;
                    cosx = -c;
                    break;
                default:
                    sinx = -c;
                    cosx = s;
                    break;
            }
            cosx += 0;
            if (sinx === 0) sinx = m.copysign(sinx, x + t);
            return {
                s: sinx,
                c: cosx
            };
        };
        m.atan2d = function(y, x) {
            var q = 0, ang;
            if (Math.abs(y) > Math.abs(x)) {
                [y, x] = [
                    x,
                    y
                ];
                q = 2;
            }
            if (m.copysign(1, x) < 0) {
                x = -x;
                ++q;
            }
            ang = Math.atan2(y, x) / this.degree;
            switch(q){
                case 1:
                    ang = m.copysign(180, y) - ang;
                    break;
                case 2:
                    ang = 90 - ang;
                    break;
                case 3:
                    ang = -90 + ang;
                    break;
                default:
                    break;
            }
            return ang;
        };
    })(geodesic.Math);
    (function(a, m) {
        "use strict";
        a.Accumulator = function(y) {
            this.Set(y);
        };
        a.Accumulator.prototype.Set = function(y) {
            if (!y) y = 0;
            if (y.constructor === a.Accumulator) {
                this._s = y._s;
                this._t = y._t;
            } else {
                this._s = y;
                this._t = 0;
            }
        };
        a.Accumulator.prototype.Add = function(y) {
            var u = m.sum(y, this._t), v = m.sum(u.s, this._s);
            u = u.t;
            this._s = v.s;
            this._t = v.t;
            if (this._s === 0) this._s = u;
            else this._t += u;
        };
        a.Accumulator.prototype.Sum = function(y) {
            var b;
            if (!y) return this._s;
            else {
                b = new a.Accumulator(this);
                b.Add(y);
                return b._s;
            }
        };
        a.Accumulator.prototype.Negate = function() {
            this._s *= -1;
            this._t *= -1;
        };
        a.Accumulator.prototype.Remainder = function(y) {
            this._s = m.remainder(this._s, y);
            this.Add(0);
        };
    })(geodesic.Accumulator, geodesic.Math);
    geodesic.Geodesic = {};
    geodesic.GeodesicLine = {};
    geodesic.PolygonArea = {};
    (function(g, l, p, m, c) {
        "use strict";
        var GEOGRAPHICLIB_GEODESIC_ORDER = 6, nA1_ = GEOGRAPHICLIB_GEODESIC_ORDER, nA2_ = GEOGRAPHICLIB_GEODESIC_ORDER, nA3_ = GEOGRAPHICLIB_GEODESIC_ORDER, nA3x_ = nA3_, nC3x_, nC4x_, maxit1_ = 20, maxit2_ = maxit1_ + m.digits + 10, tol0_ = m.epsilon, tol1_ = 200 * tol0_, tol2_ = Math.sqrt(tol0_), tolb_ = tol0_, xthresh_ = 1000 * tol2_, CAP_NONE = 0, CAP_ALL = 0x1F, OUT_ALL = 0x7F80, astroid, A1m1f_coeff, C1f_coeff, C1pf_coeff, A2m1f_coeff, C2f_coeff, A3_coeff, C3_coeff, C4_coeff;
        g.tiny_ = Math.sqrt(Number.MIN_VALUE / Number.EPSILON);
        g.nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER;
        g.nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;
        g.nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;
        g.nC3_ = GEOGRAPHICLIB_GEODESIC_ORDER;
        g.nC4_ = GEOGRAPHICLIB_GEODESIC_ORDER;
        nC3x_ = g.nC3_ * (g.nC3_ - 1) / 2;
        nC4x_ = g.nC4_ * (g.nC4_ + 1) / 2;
        g.CAP_C1 = 1 << 0;
        g.CAP_C1p = 1 << 1;
        g.CAP_C2 = 1 << 2;
        g.CAP_C3 = 1 << 3;
        g.CAP_C4 = 1 << 4;
        g.NONE = 0;
        g.ARC = 1 << 6;
        g.LATITUDE = 1 << 7 | CAP_NONE;
        g.LONGITUDE = 1 << 8 | g.CAP_C3;
        g.AZIMUTH = 1 << 9 | CAP_NONE;
        g.DISTANCE = 1 << 10 | g.CAP_C1;
        g.STANDARD = g.LATITUDE | g.LONGITUDE | g.AZIMUTH | g.DISTANCE;
        g.DISTANCE_IN = 1 << 11 | g.CAP_C1 | g.CAP_C1p;
        g.REDUCEDLENGTH = 1 << 12 | g.CAP_C1 | g.CAP_C2;
        g.GEODESICSCALE = 1 << 13 | g.CAP_C1 | g.CAP_C2;
        g.AREA = 1 << 14 | g.CAP_C4;
        g.ALL = OUT_ALL | CAP_ALL;
        g.LONG_UNROLL = 1 << 15;
        g.OUT_MASK = OUT_ALL | g.LONG_UNROLL;
        g.SinCosSeries = function(sinp, sinx, cosx, c) {
            var k = c.length, n = k - (sinp ? 1 : 0), ar = 2 * (cosx - sinx) * (cosx + sinx), y0 = n & 1 ? c[--k] : 0, y1 = 0;
            n = Math.floor(n / 2);
            while(n--){
                y1 = ar * y0 - y1 + c[--k];
                y0 = ar * y1 - y0 + c[--k];
            }
            return sinp ? 2 * sinx * cosx * y0 : cosx * (y0 - y1);
        };
        astroid = function(x, y) {
            var k, p = m.sq(x), q = m.sq(y), r = (p + q - 1) / 6, S, r2, r3, disc, u, T3, T, ang, v, uv, w;
            if (!(q === 0 && r <= 0)) {
                S = p * q / 4;
                r2 = m.sq(r);
                r3 = r * r2;
                disc = S * (S + 2 * r3);
                u = r;
                if (disc >= 0) {
                    T3 = S + r3;
                    T3 += T3 < 0 ? -Math.sqrt(disc) : Math.sqrt(disc);
                    T = m.cbrt(T3);
                    u += T + (T !== 0 ? r2 / T : 0);
                } else {
                    ang = Math.atan2(Math.sqrt(-disc), -(S + r3));
                    u += 2 * r * Math.cos(ang / 3);
                }
                v = Math.sqrt(m.sq(u) + q);
                uv = u < 0 ? q / (v - u) : u + v;
                w = (uv - q) / (2 * v);
                k = uv / (Math.sqrt(uv + m.sq(w)) + w);
            } else {
                k = 0;
            }
            return k;
        };
        A1m1f_coeff = [
            +1,
            4,
            64,
            0,
            256
        ];
        g.A1m1f = function(eps) {
            var p = Math.floor(nA1_ / 2), t = m.polyval(p, A1m1f_coeff, 0, m.sq(eps)) / A1m1f_coeff[p + 1];
            return (t + eps) / (1 - eps);
        };
        C1f_coeff = [
            -1,
            6,
            -16,
            32,
            -9,
            64,
            -128,
            2048,
            +9,
            -16,
            768,
            +3,
            -5,
            512,
            -7,
            1280,
            -7,
            2048
        ];
        g.C1f = function(eps, c) {
            var eps2 = m.sq(eps), d = eps, o = 0, l, p;
            for(l = 1; l <= g.nC1_; ++l){
                p = Math.floor((g.nC1_ - l) / 2);
                c[l] = d * m.polyval(p, C1f_coeff, o, eps2) / C1f_coeff[o + p + 1];
                o += p + 2;
                d *= eps;
            }
        };
        C1pf_coeff = [
            +205,
            -432,
            768,
            1536,
            +4005,
            -4736,
            3840,
            12288,
            -225,
            116,
            384,
            -7173,
            2695,
            7680,
            +3467,
            7680,
            +38081,
            61440
        ];
        g.C1pf = function(eps, c) {
            var eps2 = m.sq(eps), d = eps, o = 0, l, p;
            for(l = 1; l <= g.nC1p_; ++l){
                p = Math.floor((g.nC1p_ - l) / 2);
                c[l] = d * m.polyval(p, C1pf_coeff, o, eps2) / C1pf_coeff[o + p + 1];
                o += p + 2;
                d *= eps;
            }
        };
        A2m1f_coeff = [
            -11,
            -28,
            -192,
            0,
            256
        ];
        g.A2m1f = function(eps) {
            var p = Math.floor(nA2_ / 2), t = m.polyval(p, A2m1f_coeff, 0, m.sq(eps)) / A2m1f_coeff[p + 1];
            return (t - eps) / (1 + eps);
        };
        C2f_coeff = [
            +1,
            2,
            16,
            32,
            +35,
            64,
            384,
            2048,
            +15,
            80,
            768,
            +7,
            35,
            512,
            +63,
            1280,
            +77,
            2048
        ];
        g.C2f = function(eps, c) {
            var eps2 = m.sq(eps), d = eps, o = 0, l, p;
            for(l = 1; l <= g.nC2_; ++l){
                p = Math.floor((g.nC2_ - l) / 2);
                c[l] = d * m.polyval(p, C2f_coeff, o, eps2) / C2f_coeff[o + p + 1];
                o += p + 2;
                d *= eps;
            }
        };
        g.Geodesic = function(a, f) {
            this.a = a;
            this.f = f;
            this._f1 = 1 - this.f;
            this._e2 = this.f * (2 - this.f);
            this._ep2 = this._e2 / m.sq(this._f1);
            this._n = this.f / (2 - this.f);
            this._b = this.a * this._f1;
            this._c2 = (m.sq(this.a) + m.sq(this._b) * (this._e2 === 0 ? 1 : (this._e2 > 0 ? m.atanh(Math.sqrt(this._e2)) : Math.atan(Math.sqrt(-this._e2))) / Math.sqrt(Math.abs(this._e2)))) / 2;
            this._etol2 = 0.1 * tol2_ / Math.sqrt(Math.max(0.001, Math.abs(this.f)) * Math.min(1, 1 - this.f / 2) / 2);
            if (!(isFinite(this.a) && this.a > 0)) throw new Error("Equatorial radius is not positive");
            if (!(isFinite(this._b) && this._b > 0)) throw new Error("Polar semi-axis is not positive");
            this._A3x = new Array(nA3x_);
            this._C3x = new Array(nC3x_);
            this._C4x = new Array(nC4x_);
            this.A3coeff();
            this.C3coeff();
            this.C4coeff();
        };
        A3_coeff = [
            -3,
            128,
            -2,
            -3,
            64,
            -1,
            -3,
            -1,
            16,
            +3,
            -1,
            -2,
            8,
            +1,
            -1,
            2,
            +1,
            1
        ];
        g.Geodesic.prototype.A3coeff = function() {
            var o = 0, k = 0, j, p;
            for(j = nA3_ - 1; j >= 0; --j){
                p = Math.min(nA3_ - j - 1, j);
                this._A3x[k++] = m.polyval(p, A3_coeff, o, this._n) / A3_coeff[o + p + 1];
                o += p + 2;
            }
        };
        C3_coeff = [
            +3,
            128,
            +2,
            5,
            128,
            -1,
            3,
            3,
            64,
            -1,
            0,
            1,
            8,
            -1,
            1,
            4,
            +5,
            256,
            +1,
            3,
            128,
            -3,
            -2,
            3,
            64,
            +1,
            -3,
            2,
            32,
            +7,
            512,
            -10,
            9,
            384,
            +5,
            -9,
            5,
            192,
            +7,
            512,
            -14,
            7,
            512,
            +21,
            2560
        ];
        g.Geodesic.prototype.C3coeff = function() {
            var o = 0, k = 0, l, j, p;
            for(l = 1; l < g.nC3_; ++l){
                for(j = g.nC3_ - 1; j >= l; --j){
                    p = Math.min(g.nC3_ - j - 1, j);
                    this._C3x[k++] = m.polyval(p, C3_coeff, o, this._n) / C3_coeff[o + p + 1];
                    o += p + 2;
                }
            }
        };
        C4_coeff = [
            +97,
            15015,
            +1088,
            156,
            45045,
            -224,
            -4784,
            1573,
            45045,
            -10656,
            14144,
            -4576,
            -858,
            45045,
            +64,
            624,
            -4576,
            6864,
            -3003,
            15015,
            +100,
            208,
            572,
            3432,
            -12012,
            30030,
            45045,
            +1,
            9009,
            -2944,
            468,
            135135,
            +5792,
            1040,
            -1287,
            135135,
            +5952,
            -11648,
            9152,
            -2574,
            135135,
            -64,
            -624,
            4576,
            -6864,
            3003,
            135135,
            +8,
            10725,
            +1856,
            -936,
            225225,
            -8448,
            4992,
            -1144,
            225225,
            -1440,
            4160,
            -4576,
            1716,
            225225,
            -136,
            63063,
            +1024,
            -208,
            105105,
            +3584,
            -3328,
            1144,
            315315,
            -128,
            135135,
            -2560,
            832,
            405405,
            +128,
            99099
        ];
        g.Geodesic.prototype.C4coeff = function() {
            var o = 0, k = 0, l, j, p;
            for(l = 0; l < g.nC4_; ++l){
                for(j = g.nC4_ - 1; j >= l; --j){
                    p = g.nC4_ - j - 1;
                    this._C4x[k++] = m.polyval(p, C4_coeff, o, this._n) / C4_coeff[o + p + 1];
                    o += p + 2;
                }
            }
        };
        g.Geodesic.prototype.A3f = function(eps) {
            return m.polyval(nA3x_ - 1, this._A3x, 0, eps);
        };
        g.Geodesic.prototype.C3f = function(eps, c) {
            var mult = 1, o = 0, l, p;
            for(l = 1; l < g.nC3_; ++l){
                p = g.nC3_ - l - 1;
                mult *= eps;
                c[l] = mult * m.polyval(p, this._C3x, o, eps);
                o += p + 1;
            }
        };
        g.Geodesic.prototype.C4f = function(eps, c) {
            var mult = 1, o = 0, l, p;
            for(l = 0; l < g.nC4_; ++l){
                p = g.nC4_ - l - 1;
                c[l] = mult * m.polyval(p, this._C4x, o, eps);
                o += p + 1;
                mult *= eps;
            }
        };
        g.Geodesic.prototype.Lengths = function(eps, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2, outmask, C1a, C2a) {
            outmask &= g.OUT_MASK;
            var vals = {}, m0x = 0, J12 = 0, A1 = 0, A2 = 0, B1, B2, l, csig12, t;
            if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {
                A1 = g.A1m1f(eps);
                g.C1f(eps, C1a);
                if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
                    A2 = g.A2m1f(eps);
                    g.C2f(eps, C2a);
                    m0x = A1 - A2;
                    A2 = 1 + A2;
                }
                A1 = 1 + A1;
            }
            if (outmask & g.DISTANCE) {
                B1 = g.SinCosSeries(true, ssig2, csig2, C1a) - g.SinCosSeries(true, ssig1, csig1, C1a);
                vals.s12b = A1 * (sig12 + B1);
                if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
                    B2 = g.SinCosSeries(true, ssig2, csig2, C2a) - g.SinCosSeries(true, ssig1, csig1, C2a);
                    J12 = m0x * sig12 + (A1 * B1 - A2 * B2);
                }
            } else if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
                for(l = 1; l <= g.nC2_; ++l)C2a[l] = A1 * C1a[l] - A2 * C2a[l];
                J12 = m0x * sig12 + (g.SinCosSeries(true, ssig2, csig2, C2a) - g.SinCosSeries(true, ssig1, csig1, C2a));
            }
            if (outmask & g.REDUCEDLENGTH) {
                vals.m0 = m0x;
                vals.m12b = dn2 * (csig1 * ssig2) - dn1 * (ssig1 * csig2) - csig1 * csig2 * J12;
            }
            if (outmask & g.GEODESICSCALE) {
                csig12 = csig1 * csig2 + ssig1 * ssig2;
                t = this._ep2 * (cbet1 - cbet2) * (cbet1 + cbet2) / (dn1 + dn2);
                vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * ssig1 / dn1;
                vals.M21 = csig12 - (t * ssig1 - csig1 * J12) * ssig2 / dn2;
            }
            return vals;
        };
        g.Geodesic.prototype.InverseStart = function(sbet1, cbet1, dn1, sbet2, cbet2, dn2, lam12, slam12, clam12, C1a, C2a) {
            var vals = {}, sbet12 = sbet2 * cbet1 - cbet2 * sbet1, cbet12 = cbet2 * cbet1 + sbet2 * sbet1, sbet12a, shortline, omg12, sbetm2, somg12, comg12, t, ssig12, csig12, x, y, lamscale, betscale, k2, eps, cbet12a, bet12a, m12b, m0, nvals, k, omg12a, lam12x;
            vals.sig12 = -1;
            sbet12a = sbet2 * cbet1;
            sbet12a += cbet2 * sbet1;
            shortline = cbet12 >= 0 && sbet12 < 0.5 && cbet2 * lam12 < 0.5;
            if (shortline) {
                sbetm2 = m.sq(sbet1 + sbet2);
                sbetm2 /= sbetm2 + m.sq(cbet1 + cbet2);
                vals.dnm = Math.sqrt(1 + this._ep2 * sbetm2);
                omg12 = lam12 / (this._f1 * vals.dnm);
                somg12 = Math.sin(omg12);
                comg12 = Math.cos(omg12);
            } else {
                somg12 = slam12;
                comg12 = clam12;
            }
            vals.salp1 = cbet2 * somg12;
            vals.calp1 = comg12 >= 0 ? sbet12 + cbet2 * sbet1 * m.sq(somg12) / (1 + comg12) : sbet12a - cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);
            ssig12 = m.hypot(vals.salp1, vals.calp1);
            csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;
            if (shortline && ssig12 < this._etol2) {
                vals.salp2 = cbet1 * somg12;
                vals.calp2 = sbet12 - cbet1 * sbet2 * (comg12 >= 0 ? m.sq(somg12) / (1 + comg12) : 1 - comg12);
                t = m.hypot(vals.salp2, vals.calp2);
                vals.salp2 /= t;
                vals.calp2 /= t;
                vals.sig12 = Math.atan2(ssig12, csig12);
            } else if (Math.abs(this._n) > 0.1 || csig12 >= 0 || ssig12 >= 6 * Math.abs(this._n) * Math.PI * m.sq(cbet1)) {} else {
                lam12x = Math.atan2(-slam12, -clam12);
                if (this.f >= 0) {
                    k2 = m.sq(sbet1) * this._ep2;
                    eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
                    lamscale = this.f * cbet1 * this.A3f(eps) * Math.PI;
                    betscale = lamscale * cbet1;
                    x = lam12x / lamscale;
                    y = sbet12a / betscale;
                } else {
                    cbet12a = cbet2 * cbet1 - sbet2 * sbet1;
                    bet12a = Math.atan2(sbet12a, cbet12a);
                    nvals = this.Lengths(this._n, Math.PI + bet12a, sbet1, -cbet1, dn1, sbet2, cbet2, dn2, cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);
                    m12b = nvals.m12b;
                    m0 = nvals.m0;
                    x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);
                    betscale = x < -0.01 ? sbet12a / x : -this.f * m.sq(cbet1) * Math.PI;
                    lamscale = betscale / cbet1;
                    y = lam12 / lamscale;
                }
                if (y > -tol1_ && x > -1 - xthresh_) {
                    if (this.f >= 0) {
                        vals.salp1 = Math.min(1, -x);
                        vals.calp1 = -Math.sqrt(1 - m.sq(vals.salp1));
                    } else {
                        vals.calp1 = Math.max(x > -tol1_ ? 0 : -1, x);
                        vals.salp1 = Math.sqrt(1 - m.sq(vals.calp1));
                    }
                } else {
                    k = astroid(x, y);
                    omg12a = lamscale * (this.f >= 0 ? -x * k / (1 + k) : -y * (1 + k) / k);
                    somg12 = Math.sin(omg12a);
                    comg12 = -Math.cos(omg12a);
                    vals.salp1 = cbet2 * somg12;
                    vals.calp1 = sbet12a - cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);
                }
            }
            if (!(vals.salp1 <= 0)) {
                t = m.hypot(vals.salp1, vals.calp1);
                vals.salp1 /= t;
                vals.calp1 /= t;
            } else {
                vals.salp1 = 1;
                vals.calp1 = 0;
            }
            return vals;
        };
        g.Geodesic.prototype.Lambda12 = function(sbet1, cbet1, dn1, sbet2, cbet2, dn2, salp1, calp1, slam120, clam120, diffp, C1a, C2a, C3a) {
            var vals = {}, t, salp0, calp0, somg1, comg1, somg2, comg2, somg12, comg12, B312, eta, k2, nvals;
            if (sbet1 === 0 && calp1 === 0) calp1 = -g.tiny_;
            salp0 = salp1 * cbet1;
            calp0 = m.hypot(calp1, salp1 * sbet1);
            vals.ssig1 = sbet1;
            somg1 = salp0 * sbet1;
            vals.csig1 = comg1 = calp1 * cbet1;
            t = m.hypot(vals.ssig1, vals.csig1);
            vals.ssig1 /= t;
            vals.csig1 /= t;
            vals.salp2 = cbet2 !== cbet1 ? salp0 / cbet2 : salp1;
            vals.calp2 = cbet2 !== cbet1 || Math.abs(sbet2) !== -sbet1 ? Math.sqrt(m.sq(calp1 * cbet1) + (cbet1 < -sbet1 ? (cbet2 - cbet1) * (cbet1 + cbet2) : (sbet1 - sbet2) * (sbet1 + sbet2))) / cbet2 : Math.abs(calp1);
            vals.ssig2 = sbet2;
            somg2 = salp0 * sbet2;
            vals.csig2 = comg2 = vals.calp2 * cbet2;
            t = m.hypot(vals.ssig2, vals.csig2);
            vals.ssig2 /= t;
            vals.csig2 /= t;
            vals.sig12 = Math.atan2(Math.max(0, vals.csig1 * vals.ssig2 - vals.ssig1 * vals.csig2), vals.csig1 * vals.csig2 + vals.ssig1 * vals.ssig2);
            somg12 = Math.max(0, comg1 * somg2 - somg1 * comg2);
            comg12 = comg1 * comg2 + somg1 * somg2;
            eta = Math.atan2(somg12 * clam120 - comg12 * slam120, comg12 * clam120 + somg12 * slam120);
            k2 = m.sq(calp0) * this._ep2;
            vals.eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
            this.C3f(vals.eps, C3a);
            B312 = g.SinCosSeries(true, vals.ssig2, vals.csig2, C3a) - g.SinCosSeries(true, vals.ssig1, vals.csig1, C3a);
            vals.domg12 = -this.f * this.A3f(vals.eps) * salp0 * (vals.sig12 + B312);
            vals.lam12 = eta + vals.domg12;
            if (diffp) {
                if (vals.calp2 === 0) vals.dlam12 = -2 * this._f1 * dn1 / sbet1;
                else {
                    nvals = this.Lengths(vals.eps, vals.sig12, vals.ssig1, vals.csig1, dn1, vals.ssig2, vals.csig2, dn2, cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);
                    vals.dlam12 = nvals.m12b;
                    vals.dlam12 *= this._f1 / (vals.calp2 * cbet2);
                }
            }
            return vals;
        };
        g.Geodesic.prototype.Inverse = function(lat1, lon1, lat2, lon2, outmask) {
            var r, vals;
            if (!outmask) outmask = g.STANDARD;
            if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
            outmask &= g.OUT_MASK;
            r = this.InverseInt(lat1, lon1, lat2, lon2, outmask);
            vals = r.vals;
            if (outmask & g.AZIMUTH) {
                vals.azi1 = m.atan2d(r.salp1, r.calp1);
                vals.azi2 = m.atan2d(r.salp2, r.calp2);
            }
            return vals;
        };
        g.Geodesic.prototype.InverseInt = function(lat1, lon1, lat2, lon2, outmask) {
            var vals = {}, lon12, lon12s, lonsign, t, swapp, latsign, sbet1, cbet1, sbet2, cbet2, s12x, m12x, dn1, dn2, lam12, slam12, clam12, sig12, calp1, salp1, calp2, salp2, C1a, C2a, C3a, meridian, nvals, ssig1, csig1, ssig2, csig2, eps, omg12, dnm, numit, salp1a, calp1a, salp1b, calp1b, tripn, tripb, v, dv, dalp1, sdalp1, cdalp1, nsalp1, lengthmask, salp0, calp0, alp12, k2, A4, C4a, B41, B42, somg12, comg12, domg12, dbet1, dbet2, salp12, calp12, sdomg12, cdomg12;
            vals.lat1 = lat1 = m.LatFix(lat1);
            vals.lat2 = lat2 = m.LatFix(lat2);
            lat1 = m.AngRound(lat1);
            lat2 = m.AngRound(lat2);
            lon12 = m.AngDiff(lon1, lon2);
            lon12s = lon12.e;
            lon12 = lon12.d;
            if (outmask & g.LONG_UNROLL) {
                vals.lon1 = lon1;
                vals.lon2 = lon1 + lon12 + lon12s;
            } else {
                vals.lon1 = m.AngNormalize(lon1);
                vals.lon2 = m.AngNormalize(lon2);
            }
            lonsign = m.copysign(1, lon12);
            lon12 *= lonsign;
            lon12s *= lonsign;
            lam12 = lon12 * m.degree;
            t = m.sincosde(lon12, lon12s);
            slam12 = t.s;
            clam12 = t.c;
            lon12s = 180 - lon12 - lon12s;
            swapp = Math.abs(lat1) < Math.abs(lat2) || isNaN(lat2) ? -1 : 1;
            if (swapp < 0) {
                lonsign *= -1;
                [lat2, lat1] = [
                    lat1,
                    lat2
                ];
            }
            latsign = m.copysign(1, -lat1);
            lat1 *= latsign;
            lat2 *= latsign;
            t = m.sincosd(lat1);
            sbet1 = this._f1 * t.s;
            cbet1 = t.c;
            t = m.hypot(sbet1, cbet1);
            sbet1 /= t;
            cbet1 /= t;
            cbet1 = Math.max(g.tiny_, cbet1);
            t = m.sincosd(lat2);
            sbet2 = this._f1 * t.s;
            cbet2 = t.c;
            t = m.hypot(sbet2, cbet2);
            sbet2 /= t;
            cbet2 /= t;
            cbet2 = Math.max(g.tiny_, cbet2);
            if (cbet1 < -sbet1) {
                if (cbet2 === cbet1) sbet2 = m.copysign(sbet1, sbet2);
            } else {
                if (Math.abs(sbet2) === -sbet1) cbet2 = cbet1;
            }
            dn1 = Math.sqrt(1 + this._ep2 * m.sq(sbet1));
            dn2 = Math.sqrt(1 + this._ep2 * m.sq(sbet2));
            C1a = new Array(g.nC1_ + 1);
            C2a = new Array(g.nC2_ + 1);
            C3a = new Array(g.nC3_);
            meridian = lat1 === -90 || slam12 === 0;
            if (meridian) {
                calp1 = clam12;
                salp1 = slam12;
                calp2 = 1;
                salp2 = 0;
                ssig1 = sbet1;
                csig1 = calp1 * cbet1;
                ssig2 = sbet2;
                csig2 = calp2 * cbet2;
                sig12 = Math.atan2(Math.max(0, csig1 * ssig2 - ssig1 * csig2), csig1 * csig2 + ssig1 * ssig2);
                nvals = this.Lengths(this._n, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2, outmask | g.DISTANCE | g.REDUCEDLENGTH, C1a, C2a);
                s12x = nvals.s12b;
                m12x = nvals.m12b;
                if (outmask & g.GEODESICSCALE) {
                    vals.M12 = nvals.M12;
                    vals.M21 = nvals.M21;
                }
                if (sig12 < 1 || m12x >= 0) {
                    if (sig12 < 3 * g.tiny_ || sig12 < tol0_ && (s12x < 0 || m12x < 0)) sig12 = m12x = s12x = 0;
                    m12x *= this._b;
                    s12x *= this._b;
                    vals.a12 = sig12 / m.degree;
                } else meridian = false;
            }
            somg12 = 2;
            if (!meridian && sbet1 === 0 && (this.f <= 0 || lon12s >= this.f * 180)) {
                calp1 = calp2 = 0;
                salp1 = salp2 = 1;
                s12x = this.a * lam12;
                sig12 = omg12 = lam12 / this._f1;
                m12x = this._b * Math.sin(sig12);
                if (outmask & g.GEODESICSCALE) vals.M12 = vals.M21 = Math.cos(sig12);
                vals.a12 = lon12 / this._f1;
            } else if (!meridian) {
                nvals = this.InverseStart(sbet1, cbet1, dn1, sbet2, cbet2, dn2, lam12, slam12, clam12, C1a, C2a);
                sig12 = nvals.sig12;
                salp1 = nvals.salp1;
                calp1 = nvals.calp1;
                if (sig12 >= 0) {
                    salp2 = nvals.salp2;
                    calp2 = nvals.calp2;
                    dnm = nvals.dnm;
                    s12x = sig12 * this._b * dnm;
                    m12x = m.sq(dnm) * this._b * Math.sin(sig12 / dnm);
                    if (outmask & g.GEODESICSCALE) vals.M12 = vals.M21 = Math.cos(sig12 / dnm);
                    vals.a12 = sig12 / m.degree;
                    omg12 = lam12 / (this._f1 * dnm);
                } else {
                    numit = 0;
                    salp1a = g.tiny_;
                    calp1a = 1;
                    salp1b = g.tiny_;
                    calp1b = -1;
                    for(tripn = false, tripb = false;; ++numit){
                        nvals = this.Lambda12(sbet1, cbet1, dn1, sbet2, cbet2, dn2, salp1, calp1, slam12, clam12, numit < maxit1_, C1a, C2a, C3a);
                        v = nvals.lam12;
                        salp2 = nvals.salp2;
                        calp2 = nvals.calp2;
                        sig12 = nvals.sig12;
                        ssig1 = nvals.ssig1;
                        csig1 = nvals.csig1;
                        ssig2 = nvals.ssig2;
                        csig2 = nvals.csig2;
                        eps = nvals.eps;
                        domg12 = nvals.domg12;
                        dv = nvals.dlam12;
                        if (tripb || !(Math.abs(v) >= (tripn ? 8 : 1) * tol0_) || numit == maxit2_) break;
                        if (v > 0 && (numit < maxit1_ || calp1 / salp1 > calp1b / salp1b)) {
                            salp1b = salp1;
                            calp1b = calp1;
                        } else if (v < 0 && (numit < maxit1_ || calp1 / salp1 < calp1a / salp1a)) {
                            salp1a = salp1;
                            calp1a = calp1;
                        }
                        if (numit < maxit1_ && dv > 0) {
                            dalp1 = -v / dv;
                            if (Math.abs(dalp1) < Math.PI) {
                                sdalp1 = Math.sin(dalp1);
                                cdalp1 = Math.cos(dalp1);
                                nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;
                                if (nsalp1 > 0) {
                                    calp1 = calp1 * cdalp1 - salp1 * sdalp1;
                                    salp1 = nsalp1;
                                    t = m.hypot(salp1, calp1);
                                    salp1 /= t;
                                    calp1 /= t;
                                    tripn = Math.abs(v) <= 16 * tol0_;
                                    continue;
                                }
                            }
                        }
                        salp1 = (salp1a + salp1b) / 2;
                        calp1 = (calp1a + calp1b) / 2;
                        t = m.hypot(salp1, calp1);
                        salp1 /= t;
                        calp1 /= t;
                        tripn = false;
                        tripb = Math.abs(salp1a - salp1) + (calp1a - calp1) < tolb_ || Math.abs(salp1 - salp1b) + (calp1 - calp1b) < tolb_;
                    }
                    lengthmask = outmask | (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE) ? g.DISTANCE : g.NONE);
                    nvals = this.Lengths(eps, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2, lengthmask, C1a, C2a);
                    s12x = nvals.s12b;
                    m12x = nvals.m12b;
                    if (outmask & g.GEODESICSCALE) {
                        vals.M12 = nvals.M12;
                        vals.M21 = nvals.M21;
                    }
                    m12x *= this._b;
                    s12x *= this._b;
                    vals.a12 = sig12 / m.degree;
                    if (outmask & g.AREA) {
                        sdomg12 = Math.sin(domg12);
                        cdomg12 = Math.cos(domg12);
                        somg12 = slam12 * cdomg12 - clam12 * sdomg12;
                        comg12 = clam12 * cdomg12 + slam12 * sdomg12;
                    }
                }
            }
            if (outmask & g.DISTANCE) vals.s12 = 0 + s12x;
            if (outmask & g.REDUCEDLENGTH) vals.m12 = 0 + m12x;
            if (outmask & g.AREA) {
                salp0 = salp1 * cbet1;
                calp0 = m.hypot(calp1, salp1 * sbet1);
                if (calp0 !== 0 && salp0 !== 0) {
                    ssig1 = sbet1;
                    csig1 = calp1 * cbet1;
                    ssig2 = sbet2;
                    csig2 = calp2 * cbet2;
                    k2 = m.sq(calp0) * this._ep2;
                    eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
                    A4 = m.sq(this.a) * calp0 * salp0 * this._e2;
                    t = m.hypot(ssig1, csig1);
                    ssig1 /= t;
                    csig1 /= t;
                    t = m.hypot(ssig2, csig2);
                    ssig2 /= t;
                    csig2 /= t;
                    C4a = new Array(g.nC4_);
                    this.C4f(eps, C4a);
                    B41 = g.SinCosSeries(false, ssig1, csig1, C4a);
                    B42 = g.SinCosSeries(false, ssig2, csig2, C4a);
                    vals.S12 = A4 * (B42 - B41);
                } else vals.S12 = 0;
                if (!meridian && somg12 == 2) {
                    somg12 = Math.sin(omg12);
                    comg12 = Math.cos(omg12);
                }
                if (!meridian && comg12 > -0.7071 && sbet2 - sbet1 < 1.75) {
                    domg12 = 1 + comg12;
                    dbet1 = 1 + cbet1;
                    dbet2 = 1 + cbet2;
                    alp12 = 2 * Math.atan2(somg12 * (sbet1 * dbet2 + sbet2 * dbet1), domg12 * (sbet1 * sbet2 + dbet1 * dbet2));
                } else {
                    salp12 = salp2 * calp1 - calp2 * salp1;
                    calp12 = calp2 * calp1 + salp2 * salp1;
                    if (salp12 === 0 && calp12 < 0) {
                        salp12 = g.tiny_ * calp1;
                        calp12 = -1;
                    }
                    alp12 = Math.atan2(salp12, calp12);
                }
                vals.S12 += this._c2 * alp12;
                vals.S12 *= swapp * lonsign * latsign;
                vals.S12 += 0;
            }
            if (swapp < 0) {
                [salp2, salp1] = [
                    salp1,
                    salp2
                ];
                [calp2, calp1] = [
                    calp1,
                    calp2
                ];
                if (outmask & g.GEODESICSCALE) {
                    [vals.M21, vals.M12] = [
                        vals.M12,
                        vals.M21
                    ];
                }
            }
            salp1 *= swapp * lonsign;
            calp1 *= swapp * latsign;
            salp2 *= swapp * lonsign;
            calp2 *= swapp * latsign;
            return {
                vals: vals,
                salp1: salp1,
                calp1: calp1,
                salp2: salp2,
                calp2: calp2
            };
        };
        g.Geodesic.prototype.GenDirect = function(lat1, lon1, azi1, arcmode, s12_a12, outmask) {
            var line;
            if (!outmask) outmask = g.STANDARD;
            else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
            if (!arcmode) outmask |= g.DISTANCE_IN;
            line = new l.GeodesicLine(this, lat1, lon1, azi1, outmask);
            return line.GenPosition(arcmode, s12_a12, outmask);
        };
        g.Geodesic.prototype.Direct = function(lat1, lon1, azi1, s12, outmask) {
            return this.GenDirect(lat1, lon1, azi1, false, s12, outmask);
        };
        g.Geodesic.prototype.ArcDirect = function(lat1, lon1, azi1, a12, outmask) {
            return this.GenDirect(lat1, lon1, azi1, true, a12, outmask);
        };
        g.Geodesic.prototype.Line = function(lat1, lon1, azi1, caps) {
            return new l.GeodesicLine(this, lat1, lon1, azi1, caps);
        };
        g.Geodesic.prototype.DirectLine = function(lat1, lon1, azi1, s12, caps) {
            return this.GenDirectLine(lat1, lon1, azi1, false, s12, caps);
        };
        g.Geodesic.prototype.ArcDirectLine = function(lat1, lon1, azi1, a12, caps) {
            return this.GenDirectLine(lat1, lon1, azi1, true, a12, caps);
        };
        g.Geodesic.prototype.GenDirectLine = function(lat1, lon1, azi1, arcmode, s12_a12, caps) {
            var t;
            if (!caps) caps = g.STANDARD | g.DISTANCE_IN;
            if (!arcmode) caps |= g.DISTANCE_IN;
            t = new l.GeodesicLine(this, lat1, lon1, azi1, caps);
            t.GenSetDistance(arcmode, s12_a12);
            return t;
        };
        g.Geodesic.prototype.InverseLine = function(lat1, lon1, lat2, lon2, caps) {
            var r, t, azi1;
            if (!caps) caps = g.STANDARD | g.DISTANCE_IN;
            r = this.InverseInt(lat1, lon1, lat2, lon2, g.ARC);
            azi1 = m.atan2d(r.salp1, r.calp1);
            if (caps & (g.OUT_MASK & g.DISTANCE_IN)) caps |= g.DISTANCE;
            t = new l.GeodesicLine(this, lat1, lon1, azi1, caps, r.salp1, r.calp1);
            t.SetArc(r.vals.a12);
            return t;
        };
        g.Geodesic.prototype.Polygon = function(polyline) {
            return new p.PolygonArea(this, polyline);
        };
        g.WGS84 = new g.Geodesic(c.WGS84.a, c.WGS84.f);
    })(geodesic.Geodesic, geodesic.GeodesicLine, geodesic.PolygonArea, geodesic.Math, geodesic.Constants);
    (function(g, l, m) {
        "use strict";
        l.GeodesicLine = function(geod, lat1, lon1, azi1, caps, salp1, calp1) {
            var t, cbet1, sbet1, eps, s, c;
            if (!caps) caps = g.STANDARD | g.DISTANCE_IN;
            this.a = geod.a;
            this.f = geod.f;
            this._b = geod._b;
            this._c2 = geod._c2;
            this._f1 = geod._f1;
            this.caps = caps | g.LATITUDE | g.AZIMUTH | g.LONG_UNROLL;
            this.lat1 = m.LatFix(lat1);
            this.lon1 = lon1;
            if (typeof salp1 === 'undefined' || typeof calp1 === 'undefined') {
                this.azi1 = m.AngNormalize(azi1);
                t = m.sincosd(m.AngRound(this.azi1));
                this.salp1 = t.s;
                this.calp1 = t.c;
            } else {
                this.azi1 = azi1;
                this.salp1 = salp1;
                this.calp1 = calp1;
            }
            t = m.sincosd(m.AngRound(this.lat1));
            sbet1 = this._f1 * t.s;
            cbet1 = t.c;
            t = m.hypot(sbet1, cbet1);
            sbet1 /= t;
            cbet1 /= t;
            cbet1 = Math.max(g.tiny_, cbet1);
            this._dn1 = Math.sqrt(1 + geod._ep2 * m.sq(sbet1));
            this._salp0 = this.salp1 * cbet1;
            this._calp0 = m.hypot(this.calp1, this.salp1 * sbet1);
            this._ssig1 = sbet1;
            this._somg1 = this._salp0 * sbet1;
            this._csig1 = this._comg1 = sbet1 !== 0 || this.calp1 !== 0 ? cbet1 * this.calp1 : 1;
            t = m.hypot(this._ssig1, this._csig1);
            this._ssig1 /= t;
            this._csig1 /= t;
            this._k2 = m.sq(this._calp0) * geod._ep2;
            eps = this._k2 / (2 * (1 + Math.sqrt(1 + this._k2)) + this._k2);
            if (this.caps & g.CAP_C1) {
                this._A1m1 = g.A1m1f(eps);
                this._C1a = new Array(g.nC1_ + 1);
                g.C1f(eps, this._C1a);
                this._B11 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C1a);
                s = Math.sin(this._B11);
                c = Math.cos(this._B11);
                this._stau1 = this._ssig1 * c + this._csig1 * s;
                this._ctau1 = this._csig1 * c - this._ssig1 * s;
            }
            if (this.caps & g.CAP_C1p) {
                this._C1pa = new Array(g.nC1p_ + 1);
                g.C1pf(eps, this._C1pa);
            }
            if (this.caps & g.CAP_C2) {
                this._A2m1 = g.A2m1f(eps);
                this._C2a = new Array(g.nC2_ + 1);
                g.C2f(eps, this._C2a);
                this._B21 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C2a);
            }
            if (this.caps & g.CAP_C3) {
                this._C3a = new Array(g.nC3_);
                geod.C3f(eps, this._C3a);
                this._A3c = -this.f * this._salp0 * geod.A3f(eps);
                this._B31 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C3a);
            }
            if (this.caps & g.CAP_C4) {
                this._C4a = new Array(g.nC4_);
                geod.C4f(eps, this._C4a);
                this._A4 = m.sq(this.a) * this._calp0 * this._salp0 * geod._e2;
                this._B41 = g.SinCosSeries(false, this._ssig1, this._csig1, this._C4a);
            }
            this.a13 = this.s13 = NaN;
        };
        l.GeodesicLine.prototype.GenPosition = function(arcmode, s12_a12, outmask) {
            var vals = {}, sig12, ssig12, csig12, B12, AB1, ssig2, csig2, tau12, s, c, serr, omg12, lam12, lon12, E, sbet2, cbet2, somg2, comg2, salp2, calp2, dn2, B22, AB2, J12, t, B42, salp12, calp12;
            if (!outmask) outmask = g.STANDARD;
            else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
            outmask &= this.caps & g.OUT_MASK;
            vals.lat1 = this.lat1;
            vals.azi1 = this.azi1;
            vals.lon1 = outmask & g.LONG_UNROLL ? this.lon1 : m.AngNormalize(this.lon1);
            if (arcmode) vals.a12 = s12_a12;
            else vals.s12 = s12_a12;
            if (!(arcmode || this.caps & g.DISTANCE_IN & g.OUT_MASK)) {
                vals.a12 = NaN;
                return vals;
            }
            B12 = 0;
            AB1 = 0;
            if (arcmode) {
                sig12 = s12_a12 * m.degree;
                t = m.sincosd(s12_a12);
                ssig12 = t.s;
                csig12 = t.c;
            } else {
                tau12 = s12_a12 / (this._b * (1 + this._A1m1));
                s = Math.sin(tau12);
                c = Math.cos(tau12);
                B12 = -g.SinCosSeries(true, this._stau1 * c + this._ctau1 * s, this._ctau1 * c - this._stau1 * s, this._C1pa);
                sig12 = tau12 - (B12 - this._B11);
                ssig12 = Math.sin(sig12);
                csig12 = Math.cos(sig12);
                if (Math.abs(this.f) > 0.01) {
                    ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
                    csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
                    B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);
                    serr = (1 + this._A1m1) * (sig12 + (B12 - this._B11)) - s12_a12 / this._b;
                    sig12 = sig12 - serr / Math.sqrt(1 + this._k2 * m.sq(ssig2));
                    ssig12 = Math.sin(sig12);
                    csig12 = Math.cos(sig12);
                }
            }
            ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
            csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
            dn2 = Math.sqrt(1 + this._k2 * m.sq(ssig2));
            if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {
                if (arcmode || Math.abs(this.f) > 0.01) B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);
                AB1 = (1 + this._A1m1) * (B12 - this._B11);
            }
            sbet2 = this._calp0 * ssig2;
            cbet2 = m.hypot(this._salp0, this._calp0 * csig2);
            if (cbet2 === 0) cbet2 = csig2 = g.tiny_;
            salp2 = this._salp0;
            calp2 = this._calp0 * csig2;
            if (arcmode && outmask & g.DISTANCE) vals.s12 = this._b * ((1 + this._A1m1) * sig12 + AB1);
            if (outmask & g.LONGITUDE) {
                somg2 = this._salp0 * ssig2;
                comg2 = csig2;
                E = m.copysign(1, this._salp0);
                omg12 = outmask & g.LONG_UNROLL ? E * (sig12 - (Math.atan2(ssig2, csig2) - Math.atan2(this._ssig1, this._csig1)) + (Math.atan2(E * somg2, comg2) - Math.atan2(E * this._somg1, this._comg1))) : Math.atan2(somg2 * this._comg1 - comg2 * this._somg1, comg2 * this._comg1 + somg2 * this._somg1);
                lam12 = omg12 + this._A3c * (sig12 + (g.SinCosSeries(true, ssig2, csig2, this._C3a) - this._B31));
                lon12 = lam12 / m.degree;
                vals.lon2 = outmask & g.LONG_UNROLL ? this.lon1 + lon12 : m.AngNormalize(m.AngNormalize(this.lon1) + m.AngNormalize(lon12));
            }
            if (outmask & g.LATITUDE) vals.lat2 = m.atan2d(sbet2, this._f1 * cbet2);
            if (outmask & g.AZIMUTH) vals.azi2 = m.atan2d(salp2, calp2);
            if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
                B22 = g.SinCosSeries(true, ssig2, csig2, this._C2a);
                AB2 = (1 + this._A2m1) * (B22 - this._B21);
                J12 = (this._A1m1 - this._A2m1) * sig12 + (AB1 - AB2);
                if (outmask & g.REDUCEDLENGTH) vals.m12 = this._b * (dn2 * (this._csig1 * ssig2) - this._dn1 * (this._ssig1 * csig2) - this._csig1 * csig2 * J12);
                if (outmask & g.GEODESICSCALE) {
                    t = this._k2 * (ssig2 - this._ssig1) * (ssig2 + this._ssig1) / (this._dn1 + dn2);
                    vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * this._ssig1 / this._dn1;
                    vals.M21 = csig12 - (t * this._ssig1 - this._csig1 * J12) * ssig2 / dn2;
                }
            }
            if (outmask & g.AREA) {
                B42 = g.SinCosSeries(false, ssig2, csig2, this._C4a);
                if (this._calp0 === 0 || this._salp0 === 0) {
                    salp12 = salp2 * this.calp1 - calp2 * this.salp1;
                    calp12 = calp2 * this.calp1 + salp2 * this.salp1;
                } else {
                    salp12 = this._calp0 * this._salp0 * (csig12 <= 0 ? this._csig1 * (1 - csig12) + ssig12 * this._ssig1 : ssig12 * (this._csig1 * ssig12 / (1 + csig12) + this._ssig1));
                    calp12 = m.sq(this._salp0) + m.sq(this._calp0) * this._csig1 * csig2;
                }
                vals.S12 = this._c2 * Math.atan2(salp12, calp12) + this._A4 * (B42 - this._B41);
            }
            if (!arcmode) vals.a12 = sig12 / m.degree;
            return vals;
        };
        l.GeodesicLine.prototype.Position = function(s12, outmask) {
            return this.GenPosition(false, s12, outmask);
        };
        l.GeodesicLine.prototype.ArcPosition = function(a12, outmask) {
            return this.GenPosition(true, a12, outmask);
        };
        l.GeodesicLine.prototype.GenSetDistance = function(arcmode, s13_a13) {
            if (arcmode) this.SetArc(s13_a13);
            else this.SetDistance(s13_a13);
        };
        l.GeodesicLine.prototype.SetDistance = function(s13) {
            var r;
            this.s13 = s13;
            r = this.GenPosition(false, this.s13, g.ARC);
            this.a13 = 0 + r.a12;
        };
        l.GeodesicLine.prototype.SetArc = function(a13) {
            var r;
            this.a13 = a13;
            r = this.GenPosition(true, this.a13, g.DISTANCE);
            this.s13 = 0 + r.s12;
        };
    })(geodesic.Geodesic, geodesic.GeodesicLine, geodesic.Math);
    (function(p, g, m, a) {
        "use strict";
        var transit, transitdirect, AreaReduceA, AreaReduceB;
        transit = function(lon1, lon2) {
            var lon12 = m.AngDiff(lon1, lon2).d;
            lon1 = m.AngNormalize(lon1);
            lon2 = m.AngNormalize(lon2);
            return lon12 > 0 && (lon1 < 0 && lon2 >= 0 || lon1 > 0 && lon2 === 0) ? 1 : lon12 < 0 && lon1 >= 0 && lon2 < 0 ? -1 : 0;
        };
        transitdirect = function(lon1, lon2) {
            lon1 = lon1 % 720;
            lon2 = lon2 % 720;
            return (0 <= lon2 && lon2 < 360 || lon2 < -360 ? 0 : 1) - (0 <= lon1 && lon1 < 360 || lon1 < -360 ? 0 : 1);
        };
        AreaReduceA = function(area, area0, crossings, reverse, sign) {
            area.Remainder(area0);
            if (crossings & 1) area.Add((area.Sum() < 0 ? 1 : -1) * area0 / 2);
            if (!reverse) area.Negate();
            if (sign) {
                if (area.Sum() > area0 / 2) area.Add(-area0);
                else if (area.Sum() <= -area0 / 2) area.Add(+area0);
            } else {
                if (area.Sum() >= area0) area.Add(-area0);
                else if (area.Sum() < 0) area.Add(+area0);
            }
            return 0 + area.Sum();
        };
        AreaReduceB = function(area, area0, crossings, reverse, sign) {
            area = m.remainder(area, area0);
            if (crossings & 1) area += (area < 0 ? 1 : -1) * area0 / 2;
            if (!reverse) area *= -1;
            if (sign) {
                if (area > area0 / 2) area -= area0;
                else if (area <= -area0 / 2) area += area0;
            } else {
                if (area >= area0) area -= area0;
                else if (area < 0) area += area0;
            }
            return 0 + area;
        };
        p.PolygonArea = function(geod, polyline) {
            this._geod = geod;
            this.a = this._geod.a;
            this.f = this._geod.f;
            this._area0 = 4 * Math.PI * geod._c2;
            this.polyline = !polyline ? false : polyline;
            this._mask = g.LATITUDE | g.LONGITUDE | g.DISTANCE | (this.polyline ? g.NONE : g.AREA | g.LONG_UNROLL);
            if (!this.polyline) this._areasum = new a.Accumulator(0);
            this._perimetersum = new a.Accumulator(0);
            this.Clear();
        };
        p.PolygonArea.prototype.Clear = function() {
            this.num = 0;
            this._crossings = 0;
            if (!this.polyline) this._areasum.Set(0);
            this._perimetersum.Set(0);
            this._lat0 = this._lon0 = this.lat = this.lon = NaN;
        };
        p.PolygonArea.prototype.AddPoint = function(lat, lon) {
            var t;
            if (this.num === 0) {
                this._lat0 = this.lat = lat;
                this._lon0 = this.lon = lon;
            } else {
                t = this._geod.Inverse(this.lat, this.lon, lat, lon, this._mask);
                this._perimetersum.Add(t.s12);
                if (!this.polyline) {
                    this._areasum.Add(t.S12);
                    this._crossings += transit(this.lon, lon);
                }
                this.lat = lat;
                this.lon = lon;
            }
            ++this.num;
        };
        p.PolygonArea.prototype.AddEdge = function(azi, s) {
            var t;
            if (this.num) {
                t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);
                this._perimetersum.Add(s);
                if (!this.polyline) {
                    this._areasum.Add(t.S12);
                    this._crossings += transitdirect(this.lon, t.lon2);
                }
                this.lat = t.lat2;
                this.lon = t.lon2;
            }
            ++this.num;
        };
        p.PolygonArea.prototype.Compute = function(reverse, sign) {
            var vals = {
                number: this.num
            }, t, tempsum;
            if (this.num < 2) {
                vals.perimeter = 0;
                if (!this.polyline) vals.area = 0;
                return vals;
            }
            if (this.polyline) {
                vals.perimeter = this._perimetersum.Sum();
                return vals;
            }
            t = this._geod.Inverse(this.lat, this.lon, this._lat0, this._lon0, this._mask);
            vals.perimeter = this._perimetersum.Sum(t.s12);
            tempsum = new a.Accumulator(this._areasum);
            tempsum.Add(t.S12);
            vals.area = AreaReduceA(tempsum, this._area0, this._crossings + transit(this.lon, this._lon0), reverse, sign);
            return vals;
        };
        p.PolygonArea.prototype.TestPoint = function(lat, lon, reverse, sign) {
            var vals = {
                number: this.num + 1
            }, t, tempsum, crossings, i;
            if (this.num === 0) {
                vals.perimeter = 0;
                if (!this.polyline) vals.area = 0;
                return vals;
            }
            vals.perimeter = this._perimetersum.Sum();
            tempsum = this.polyline ? 0 : this._areasum.Sum();
            crossings = this._crossings;
            for(i = 0; i < (this.polyline ? 1 : 2); ++i){
                t = this._geod.Inverse(i === 0 ? this.lat : lat, i === 0 ? this.lon : lon, i !== 0 ? this._lat0 : lat, i !== 0 ? this._lon0 : lon, this._mask);
                vals.perimeter += t.s12;
                if (!this.polyline) {
                    tempsum += t.S12;
                    crossings += transit(i === 0 ? this.lon : lon, i !== 0 ? this._lon0 : lon);
                }
            }
            if (this.polyline) return vals;
            vals.area = AreaReduceB(tempsum, this._area0, crossings, reverse, sign);
            return vals;
        };
        p.PolygonArea.prototype.TestEdge = function(azi, s, reverse, sign) {
            var vals = {
                number: this.num ? this.num + 1 : 0
            }, t, tempsum, crossings;
            if (this.num === 0) return vals;
            vals.perimeter = this._perimetersum.Sum() + s;
            if (this.polyline) return vals;
            tempsum = this._areasum.Sum();
            crossings = this._crossings;
            t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);
            tempsum += t.S12;
            crossings += transitdirect(this.lon, t.lon2);
            crossings += transit(t.lon2, this._lon0);
            t = this._geod.Inverse(t.lat2, t.lon2, this._lat0, this._lon0, this._mask);
            vals.perimeter += t.s12;
            tempsum += t.S12;
            vals.area = AreaReduceB(tempsum, this._area0, crossings, reverse, sign);
            return vals;
        };
    })(geodesic.PolygonArea, geodesic.Geodesic, geodesic.Math, geodesic.Accumulator);
    cb(geodesic);
})(function(geo) {
    if (("TURBOPACK compile-time value", "object") === 'object' && module.exports) {
        module.exports = geo;
    } else if (typeof define === 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return geo;
        }());
    } else {
        window.geodesic = geo;
    }
});
}}),
"[project]/node_modules/@turf/helpers/dist/js/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * @module helpers
 */ /**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */ exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */ exports.factors = {
    centimeters: exports.earthRadius * 100,
    centimetres: exports.earthRadius * 100,
    degrees: exports.earthRadius / 111325,
    feet: exports.earthRadius * 3.28084,
    inches: exports.earthRadius * 39.37,
    kilometers: exports.earthRadius / 1000,
    kilometres: exports.earthRadius / 1000,
    meters: exports.earthRadius,
    metres: exports.earthRadius,
    miles: exports.earthRadius / 1609.344,
    millimeters: exports.earthRadius * 1000,
    millimetres: exports.earthRadius * 1000,
    nauticalmiles: exports.earthRadius / 1852,
    radians: 1,
    yards: exports.earthRadius * 1.0936
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */ exports.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / exports.earthRadius,
    yards: 1.0936133
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */ exports.areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    hectares: 0.0001,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */ function feature(geom, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var feat = {
        type: "Feature"
    };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */ function geometry(type, coordinates, _options) {
    if (_options === void 0) {
        _options = {};
    }
    switch(type){
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */ function point(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    var geom = {
        type: "Point",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */ function points(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    return featureCollection(coordinates.map(function(coords) {
        return point(coords, properties);
    }), options);
}
exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */ function polygon(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    for(var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++){
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for(var j = 0; j < ring[ring.length - 1].length; j++){
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */ function polygons(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    return featureCollection(coordinates.map(function(coords) {
        return polygon(coords, properties);
    }), options);
}
exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */ function lineString(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */ function lineStrings(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    return featureCollection(coordinates.map(function(coords) {
        return lineString(coords, properties);
    }), options);
}
exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */ function featureCollection(features, options) {
    if (options === void 0) {
        options = {};
    }
    var fc = {
        type: "FeatureCollection"
    };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */ function multiLineString(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */ function multiPoint(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */ function multiPolygon(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */ function geometryCollection(geometries, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries
    };
    return feature(geom, properties, options);
}
exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */ function round(num, precision) {
    if (precision === void 0) {
        precision = 0;
    }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */ function radiansToLength(radians, units) {
    if (units === void 0) {
        units = "kilometers";
    }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */ function lengthToRadians(distance, units) {
    if (units === void 0) {
        units = "kilometers";
    }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */ function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */ function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */ function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */ function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */ function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) {
        originalUnit = "kilometers";
    }
    if (finalUnit === void 0) {
        finalUnit = "kilometers";
    }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted area
 */ function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) {
        originalUnit = "meters";
    }
    if (finalUnit === void 0) {
        finalUnit = "kilometers";
    }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = exports.areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = exports.areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return area / startFactor * finalFactor;
}
exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */ function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */ function isObject(input) {
    return !!input && input.constructor === Object;
}
exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */ function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function(num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */ function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if ([
        "string",
        "number"
    ].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
exports.validateId = validateId;
}}),
"[project]/node_modules/@turf/invariant/dist/js/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var helpers_1 = __turbopack_context__.r("[project]/node_modules/@turf/helpers/dist/js/index.js [app-ssr] (ecmascript)");
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */ function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
exports.getCoord = getCoord;
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */ function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    } else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
exports.getCoords = getCoords;
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */ function containsNumber(coordinates) {
    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
exports.containsNumber = containsNumber;
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */ function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
exports.geojsonType = geojsonType;
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */ function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
exports.featureOf = featureOf;
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */ function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for(var _i = 0, _a = featureCollection.features; _i < _a.length; _i++){
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
exports.collectionOf = collectionOf;
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */ function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
exports.getGeom = getGeom;
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message (unused)
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */ function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
exports.getType = getType;
}}),
"[project]/node_modules/@turf/boolean-point-in-polygon/dist/js/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var invariant_1 = __turbopack_context__.r("[project]/node_modules/@turf/invariant/dist/js/index.js [app-ssr] (ecmascript)");
// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
 * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
 *
 * @name booleanPointInPolygon
 * @param {Coord} point input point
 * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
 * the point is inside the polygon otherwise false.
 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt = turf.point([-77, 44]);
 * var poly = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]]);
 *
 * turf.booleanPointInPolygon(pt, poly);
 * //= true
 */ function booleanPointInPolygon(point, polygon, options) {
    if (options === void 0) {
        options = {};
    }
    // validation
    if (!point) {
        throw new Error("point is required");
    }
    if (!polygon) {
        throw new Error("polygon is required");
    }
    var pt = invariant_1.getCoord(point);
    var geom = invariant_1.getGeom(polygon);
    var type = geom.type;
    var bbox = polygon.bbox;
    var polys = geom.coordinates;
    // Quick elimination if point is not inside bbox
    if (bbox && inBBox(pt, bbox) === false) {
        return false;
    }
    // normalize to multipolygon
    if (type === "Polygon") {
        polys = [
            polys
        ];
    }
    var insidePoly = false;
    for(var i = 0; i < polys.length && !insidePoly; i++){
        // check if it is in the outer ring first
        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while(k < polys[i].length && !inHole){
                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole) {
                insidePoly = true;
            }
        }
    }
    return insidePoly;
}
exports.default = booleanPointInPolygon;
/**
 * inRing
 *
 * @private
 * @param {Array<number>} pt [x,y]
 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
 * @param {boolean} ignoreBoundary ignoreBoundary
 * @returns {boolean} inRing
 */ function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
        ring = ring.slice(0, ring.length - 1);
    }
    for(var i = 0, j = ring.length - 1; i < ring.length; j = i++){
        var xi = ring[i][0];
        var yi = ring[i][1];
        var xj = ring[j][0];
        var yj = ring[j][1];
        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
        if (onBoundary) {
            return !ignoreBoundary;
        }
        var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
        if (intersect) {
            isInside = !isInside;
        }
    }
    return isInside;
}
/**
 * inBBox
 *
 * @private
 * @param {Position} pt point [x,y]
 * @param {BBox} bbox BBox [west, south, east, north]
 * @returns {boolean} true/false if point is inside BBox
 */ function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
}}),
"[project]/node_modules/next-themes/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ThemeProvider": (()=>J),
    "useTheme": (()=>z)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
"use client";
;
var M = (e, i, s, u, m, a, l, h)=>{
    let d = document.documentElement, w = [
        "light",
        "dark"
    ];
    function p(n) {
        (Array.isArray(e) ? e : [
            e
        ]).forEach((y)=>{
            let k = y === "class", S = k && a ? m.map((f)=>a[f] || f) : m;
            k ? (d.classList.remove(...S), d.classList.add(a && a[n] ? a[n] : n)) : d.setAttribute(y, n);
        }), R(n);
    }
    function R(n) {
        h && w.includes(n) && (d.style.colorScheme = n);
    }
    function c() {
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    if (u) p(u);
    else try {
        let n = localStorage.getItem(i) || s, y = l && n === "system" ? c() : n;
        p(y);
    } catch (n) {}
};
var b = [
    "light",
    "dark"
], I = "(prefers-color-scheme: dark)", O = typeof window == "undefined", x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"])(void 0), U = {
    setTheme: (e)=>{},
    themes: []
}, z = ()=>{
    var e;
    return (e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"])(x)) != null ? e : U;
}, J = (e)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"])(x) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"], null, e.children) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(V, {
        ...e
    }), N = [
    "light",
    "dark"
], V = ({ forcedTheme: e, disableTransitionOnChange: i = !1, enableSystem: s = !0, enableColorScheme: u = !0, storageKey: m = "theme", themes: a = N, defaultTheme: l = s ? "system" : "light", attribute: h = "data-theme", value: d, children: w, nonce: p, scriptProps: R })=>{
    let [c, n] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(()=>H(m, l)), [T, y] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(()=>c === "system" ? E() : c), k = d ? Object.values(d) : a, S = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])((o)=>{
        let r = o;
        if (!r) return;
        o === "system" && s && (r = E());
        let v = d ? d[r] : r, C = i ? W(p) : null, P = document.documentElement, L = (g)=>{
            g === "class" ? (P.classList.remove(...k), v && P.classList.add(v)) : g.startsWith("data-") && (v ? P.setAttribute(g, v) : P.removeAttribute(g));
        };
        if (Array.isArray(h) ? h.forEach(L) : L(h), u) {
            let g = b.includes(l) ? l : null, D = b.includes(r) ? r : g;
            P.style.colorScheme = D;
        }
        C == null || C();
    }, [
        p
    ]), f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])((o)=>{
        let r = typeof o == "function" ? o(c) : o;
        n(r);
        try {
            localStorage.setItem(m, r);
        } catch (v) {}
    }, [
        c
    ]), A = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])((o)=>{
        let r = E(o);
        y(r), c === "system" && s && !e && S("system");
    }, [
        c,
        e
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        let o = window.matchMedia(I);
        return o.addListener(A), A(o), ()=>o.removeListener(A);
    }, [
        A
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        let o = (r)=>{
            r.key === m && (r.newValue ? n(r.newValue) : f(l));
        };
        return window.addEventListener("storage", o), ()=>window.removeEventListener("storage", o);
    }, [
        f
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        S(e != null ? e : c);
    }, [
        e,
        c
    ]);
    let Q = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"])(()=>({
            theme: c,
            setTheme: f,
            forcedTheme: e,
            resolvedTheme: c === "system" ? T : c,
            themes: s ? [
                ...a,
                "system"
            ] : a,
            systemTheme: s ? T : void 0
        }), [
        c,
        f,
        e,
        T,
        s,
        a
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(x.Provider, {
        value: Q
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(_, {
        forcedTheme: e,
        storageKey: m,
        attribute: h,
        enableSystem: s,
        enableColorScheme: u,
        defaultTheme: l,
        value: d,
        themes: a,
        nonce: p,
        scriptProps: R
    }), w);
}, _ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(({ forcedTheme: e, storageKey: i, attribute: s, enableSystem: u, enableColorScheme: m, defaultTheme: a, value: l, themes: h, nonce: d, scriptProps: w })=>{
    let p = JSON.stringify([
        s,
        i,
        a,
        e,
        h,
        l,
        u,
        m
    ]).slice(1, -1);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])("script", {
        ...w,
        suppressHydrationWarning: !0,
        nonce: typeof window == "undefined" ? d : "",
        dangerouslySetInnerHTML: {
            __html: `(${M.toString()})(${p})`
        }
    });
}), H = (e, i)=>{
    if (O) return;
    let s;
    try {
        s = localStorage.getItem(e) || void 0;
    } catch (u) {}
    return s || i;
}, W = (e)=>{
    let i = document.createElement("style");
    return e && i.setAttribute("nonce", e), i.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(i), ()=>{
        window.getComputedStyle(document.body), setTimeout(()=>{
            document.head.removeChild(i);
        }, 1);
    };
}, E = (e)=>(e || (e = window.matchMedia(I)), e.matches ? "dark" : "light");
;
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/defaultAttributes.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license @tabler/icons-react v3.34.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": (()=>defaultAttributes)
});
var defaultAttributes = {
    outline: {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
    },
    filled: {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        fill: "currentColor",
        stroke: "none"
    }
};
;
 //# sourceMappingURL=defaultAttributes.mjs.map
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/createReactComponent.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license @tabler/icons-react v3.34.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": (()=>createReactComponent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tabler/icons-react/dist/esm/defaultAttributes.mjs [app-ssr] (ecmascript)");
;
;
const createReactComponent = (type, iconName, iconNamePascal, iconNode)=>{
    const Component = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ color = "currentColor", size = 24, stroke = 2, title, className, children, ...rest }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])("svg", {
            ref,
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"][type],
            width: size,
            height: size,
            className: [
                `tabler-icon`,
                `tabler-icon-${iconName}`,
                className
            ].join(" "),
            ...type === "filled" ? {
                fill: color
            } : {
                strokeWidth: stroke,
                stroke: color
            },
            ...rest
        }, [
            title && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])("title", {
                key: "svg-title"
            }, title),
            ...iconNode.map(([tag, attrs])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(tag, attrs)),
            ...Array.isArray(children) ? children : [
                children
            ]
        ]));
    Component.displayName = `${iconNamePascal}`;
    return Component;
};
;
 //# sourceMappingURL=createReactComponent.mjs.map
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconArrowNarrowLeft.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license @tabler/icons-react v3.34.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": (()=>IconArrowNarrowLeft)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$createReactComponent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tabler/icons-react/dist/esm/createReactComponent.mjs [app-ssr] (ecmascript)");
;
var IconArrowNarrowLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$createReactComponent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("outline", "arrow-narrow-left", "IconArrowNarrowLeft", [
    [
        "path",
        {
            "d": "M5 12l14 0",
            "key": "svg-0"
        }
    ],
    [
        "path",
        {
            "d": "M5 12l4 4",
            "key": "svg-1"
        }
    ],
    [
        "path",
        {
            "d": "M5 12l4 -4",
            "key": "svg-2"
        }
    ]
]);
;
 //# sourceMappingURL=IconArrowNarrowLeft.mjs.map
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconArrowNarrowLeft.mjs [app-ssr] (ecmascript) <export default as IconArrowNarrowLeft>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IconArrowNarrowLeft": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$icons$2f$IconArrowNarrowLeft$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$icons$2f$IconArrowNarrowLeft$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconArrowNarrowLeft.mjs [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconArrowNarrowRight.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license @tabler/icons-react v3.34.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": (()=>IconArrowNarrowRight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$createReactComponent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tabler/icons-react/dist/esm/createReactComponent.mjs [app-ssr] (ecmascript)");
;
var IconArrowNarrowRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$createReactComponent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("outline", "arrow-narrow-right", "IconArrowNarrowRight", [
    [
        "path",
        {
            "d": "M5 12l14 0",
            "key": "svg-0"
        }
    ],
    [
        "path",
        {
            "d": "M15 16l4 -4",
            "key": "svg-1"
        }
    ],
    [
        "path",
        {
            "d": "M15 8l4 4",
            "key": "svg-2"
        }
    ]
]);
;
 //# sourceMappingURL=IconArrowNarrowRight.mjs.map
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconArrowNarrowRight.mjs [app-ssr] (ecmascript) <export default as IconArrowNarrowRight>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IconArrowNarrowRight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$icons$2f$IconArrowNarrowRight$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$icons$2f$IconArrowNarrowRight$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconArrowNarrowRight.mjs [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconX.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license @tabler/icons-react v3.34.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": (()=>IconX)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$createReactComponent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tabler/icons-react/dist/esm/createReactComponent.mjs [app-ssr] (ecmascript)");
;
var IconX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$createReactComponent$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("outline", "x", "IconX", [
    [
        "path",
        {
            "d": "M18 6l-12 12",
            "key": "svg-0"
        }
    ],
    [
        "path",
        {
            "d": "M6 6l12 12",
            "key": "svg-1"
        }
    ]
]);
;
 //# sourceMappingURL=IconX.mjs.map
}}),
"[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconX.mjs [app-ssr] (ecmascript) <export default as IconX>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IconX": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$icons$2f$IconX$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tabler$2f$icons$2d$react$2f$dist$2f$esm$2f$icons$2f$IconX$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tabler/icons-react/dist/esm/icons/IconX.mjs [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/motion-utils/dist/es/is-object.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isObject": (()=>isObject)
});
function isObject(value) {
    return typeof value === "object" && value !== null;
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/warn-once.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "hasWarned": (()=>hasWarned),
    "warnOnce": (()=>warnOnce)
});
const warned = new Set();
function hasWarned(message) {
    return warned.has(message);
}
function warnOnce(condition, message, element) {
    if (condition || warned.has(message)) return;
    console.warn(message);
    if (element) console.warn(element);
    warned.add(message);
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/noop.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s({
    "noop": (()=>noop)
});
const noop = (any)=>any;
;
}}),
"[project]/node_modules/motion-utils/dist/es/global-config.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MotionGlobalConfig": (()=>MotionGlobalConfig)
});
const MotionGlobalConfig = {};
;
}}),
"[project]/node_modules/motion-utils/dist/es/array.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "addUniqueItem": (()=>addUniqueItem),
    "moveItem": (()=>moveItem),
    "removeItem": (()=>removeItem)
});
function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1) arr.push(item);
}
function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1) arr.splice(index, 1);
}
// Adapted from array-move
function moveItem([...arr], fromIndex, toIndex) {
    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
    if (startIndex >= 0 && startIndex < arr.length) {
        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
        const [item] = arr.splice(fromIndex, 1);
        arr.splice(endIndex, 0, item);
    }
    return arr;
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/subscription-manager.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SubscriptionManager": (()=>SubscriptionManager)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/array.mjs [app-ssr] (ecmascript)");
;
class SubscriptionManager {
    constructor(){
        this.subscriptions = [];
    }
    add(handler) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addUniqueItem"])(this.subscriptions, handler);
        return ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["removeItem"])(this.subscriptions, handler);
    }
    notify(a, b, c) {
        const numSubscriptions = this.subscriptions.length;
        if (!numSubscriptions) return;
        if (numSubscriptions === 1) {
            /**
             * If there's only a single handler we can just call it without invoking a loop.
             */ this.subscriptions[0](a, b, c);
        } else {
            for(let i = 0; i < numSubscriptions; i++){
                /**
                 * Check whether the handler exists before firing as it's possible
                 * the subscriptions were modified during this loop running.
                 */ const handler = this.subscriptions[i];
                handler && handler(a, b, c);
            }
        }
    }
    getSize() {
        return this.subscriptions.length;
    }
    clear() {
        this.subscriptions.length = 0;
    }
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/velocity-per-second.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
  Convert velocity into velocity per second

  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/ __turbopack_context__.s({
    "velocityPerSecond": (()=>velocityPerSecond)
});
function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1000 / frameDuration) : 0;
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/errors.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "invariant": (()=>invariant),
    "warning": (()=>warning)
});
let warning = ()=>{};
let invariant = ()=>{};
if ("TURBOPACK compile-time truthy", 1) {
    warning = (check, message)=>{
        if (!check && typeof console !== "undefined") {
            console.warn(message);
        }
    };
    invariant = (check, message)=>{
        if (!check) {
            throw new Error(message);
        }
    };
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/pipe.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Pipe
 * Compose other transformers to run linearily
 * pipe(min(20), max(40))
 * @param  {...functions} transformers
 * @return {function}
 */ __turbopack_context__.s({
    "pipe": (()=>pipe)
});
const combineFunctions = (a, b)=>(v)=>b(a(v));
const pipe = (...transformers)=>transformers.reduce(combineFunctions);
;
}}),
"[project]/node_modules/motion-utils/dist/es/clamp.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clamp": (()=>clamp)
});
const clamp = (min, max, v)=>{
    if (v > max) return max;
    if (v < min) return min;
    return v;
};
;
}}),
"[project]/node_modules/motion-utils/dist/es/time-conversion.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Converts seconds to milliseconds
 *
 * @param seconds - Time in seconds.
 * @return milliseconds - Converted time in milliseconds.
 */ /*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s({
    "millisecondsToSeconds": (()=>millisecondsToSeconds),
    "secondsToMilliseconds": (()=>secondsToMilliseconds)
});
const secondsToMilliseconds = (seconds)=>seconds * 1000;
/*#__NO_SIDE_EFFECTS__*/ const millisecondsToSeconds = (milliseconds)=>milliseconds / 1000;
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cubicBezier": (()=>cubicBezier)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/noop.mjs [app-ssr] (ecmascript)");
;
/*
  Bezier function generator
  This has been modified from Gatan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/src/index.js
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  
  I've removed the newtonRaphsonIterate algo because in benchmarking it
  wasn't noticiably faster than binarySubdivision, indeed removing it
  usually improved times, depending on the curve.
  I also removed the lookup table, as for the added bundle size and loop we're
  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
  to 12 to compensate and this still tended to be faster for no perceivable
  loss in accuracy.
  Usage
    const easeOut = cubicBezier(.17,.67,.83,.67);
    const x = easeOut(0.5); // returns 0.627...
*/ // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
const calcBezier = (t, a1, a2)=>(((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;
const subdivisionPrecision = 0.0000001;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
        currentT = lowerBound + (upperBound - lowerBound) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - x;
        if (currentX > 0.0) {
            upperBound = currentT;
        } else {
            lowerBound = currentT;
        }
    }while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations)
    return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
    // If this is a linear gradient, return linear easing
    if (mX1 === mY1 && mX2 === mY2) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"];
    const getTForX = (aX)=>binarySubdivide(aX, 0, 1, mX1, mX2);
    // If animation is at start/end, return t without easing
    return (t)=>t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/ease.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "easeIn": (()=>easeIn),
    "easeInOut": (()=>easeInOut),
    "easeOut": (()=>easeOut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)");
;
const easeIn = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0.42, 0, 1, 1);
const easeOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0, 0, 0.58, 1);
const easeInOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0.42, 0, 0.58, 1);
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isEasingArray": (()=>isEasingArray)
});
const isEasingArray = (ease)=>{
    return Array.isArray(ease) && typeof ease[0] !== "number";
};
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Accepts an easing function and returns a new one that outputs mirrored values for
// the second half of the animation. Turns easeIn into easeInOut.
__turbopack_context__.s({
    "mirrorEasing": (()=>mirrorEasing)
});
const mirrorEasing = (easing)=>(p)=>p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Accepts an easing function and returns a new one that outputs reversed values.
// Turns easeIn into easeOut.
__turbopack_context__.s({
    "reverseEasing": (()=>reverseEasing)
});
const reverseEasing = (easing)=>(p)=>1 - easing(1 - p);
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/back.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "backIn": (()=>backIn),
    "backInOut": (()=>backInOut),
    "backOut": (()=>backOut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs [app-ssr] (ecmascript)");
;
;
;
const backOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(0.33, 1.53, 0.69, 0.99);
const backIn = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reverseEasing"])(backOut);
const backInOut = /*@__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mirrorEasing"])(backIn);
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/anticipate.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "anticipate": (()=>anticipate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/back.mjs [app-ssr] (ecmascript)");
;
const anticipate = (p)=>(p *= 2) < 1 ? 0.5 * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backIn"])(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/circ.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "circIn": (()=>circIn),
    "circInOut": (()=>circInOut),
    "circOut": (()=>circOut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs [app-ssr] (ecmascript)");
;
;
const circIn = (p)=>1 - Math.sin(Math.acos(p));
const circOut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$reverse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reverseEasing"])(circIn);
const circInOut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$modifiers$2f$mirror$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mirrorEasing"])(circIn);
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isBezierDefinition": (()=>isBezierDefinition)
});
const isBezierDefinition = (easing)=>Array.isArray(easing) && typeof easing[0] === "number";
;
}}),
"[project]/node_modules/motion-utils/dist/es/easing/utils/map.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "easingDefinitionToFunction": (()=>easingDefinitionToFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/errors.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/noop.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$anticipate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/anticipate.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/back.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/circ.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/ease.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$utils$2f$is$2d$bezier$2d$definition$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
const easingLookup = {
    linear: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$noop$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"],
    easeIn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeIn"],
    easeInOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeInOut"],
    easeOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$ease$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeOut"],
    circIn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circIn"],
    circInOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circInOut"],
    circOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$circ$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circOut"],
    backIn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backIn"],
    backInOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backInOut"],
    backOut: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$back$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backOut"],
    anticipate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$anticipate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["anticipate"]
};
const isValidEasing = (easing)=>{
    return typeof easing === "string";
};
const easingDefinitionToFunction = (definition)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$utils$2f$is$2d$bezier$2d$definition$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBezierDefinition"])(definition)) {
        // If cubic bezier definition, create bezier curve
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["invariant"])(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
        const [x1, y1, x2, y2] = definition;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$easing$2f$cubic$2d$bezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cubicBezier"])(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
        // Else lookup from table
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$utils$2f$dist$2f$es$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["invariant"])(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
        return easingLookup[definition];
    }
    return definition;
};
;
}}),
"[project]/node_modules/motion-utils/dist/es/progress.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
  Progress within given range

  Given a lower limit and an upper limit, we return the progress
  (expressed as a number 0-1) represented by the given value, and
  limit that progress to within 0-1.

  @param [number]: Lower limit
  @param [number]: Upper limit
  @param [number]: Value to find progress within given range
  @return [number]: Progress of value within range as expressed 0-1
*/ /*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s({
    "progress": (()=>progress)
});
const progress = (from, to, value)=>{
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
;
}}),
"[project]/node_modules/motion-utils/dist/es/memo.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*#__NO_SIDE_EFFECTS__*/ __turbopack_context__.s({
    "memo": (()=>memo)
});
function memo(callback) {
    let result;
    return ()=>{
        if (result === undefined) result = callback();
        return result;
    };
}
;
}}),
"[project]/node_modules/motion-utils/dist/es/is-numerical-string.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
 */ __turbopack_context__.s({
    "isNumericalString": (()=>isNumericalString)
});
const isNumericalString = (v)=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
;
}}),
"[project]/node_modules/motion-utils/dist/es/is-zero-value-string.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Check if the value is a zero value string like "0px" or "0%"
 */ __turbopack_context__.s({
    "isZeroValueString": (()=>isZeroValueString)
});
const isZeroValueString = (v)=>/^0[^.\s]+$/u.test(v);
;
}}),
"[project]/node_modules/simplex-noise/dist/esm/simplex-noise.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.

 Copyright (c) 2024 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */ // these __PURE__ comments help uglifyjs with dead code removal
//
__turbopack_context__.s({
    "buildPermutationTable": (()=>buildPermutationTable),
    "createNoise2D": (()=>createNoise2D),
    "createNoise3D": (()=>createNoise3D),
    "createNoise4D": (()=>createNoise4D)
});
const SQRT3 = /*#__PURE__*/ Math.sqrt(3.0);
const SQRT5 = /*#__PURE__*/ Math.sqrt(5.0);
const F2 = 0.5 * (SQRT3 - 1.0);
const G2 = (3.0 - SQRT3) / 6.0;
const F3 = 1.0 / 3.0;
const G3 = 1.0 / 6.0;
const F4 = (SQRT5 - 1.0) / 4.0;
const G4 = (5.0 - SQRT5) / 20.0;
// I'm really not sure why this | 0 (basically a coercion to int)
// is making this faster but I get ~5 million ops/sec more on the
// benchmarks across the board or a ~10% speedup.
const fastFloor = (x)=>Math.floor(x) | 0;
const grad2 = /*#__PURE__*/ new Float64Array([
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    0,
    -1,
    0,
    1,
    0,
    -1,
    0,
    0,
    1,
    0,
    -1,
    0,
    1,
    0,
    -1
]);
// double seems to be faster than single or int's
// probably because most operations are in double precision
const grad3 = /*#__PURE__*/ new Float64Array([
    1,
    1,
    0,
    -1,
    1,
    0,
    1,
    -1,
    0,
    -1,
    -1,
    0,
    1,
    0,
    1,
    -1,
    0,
    1,
    1,
    0,
    -1,
    -1,
    0,
    -1,
    0,
    1,
    1,
    0,
    -1,
    1,
    0,
    1,
    -1,
    0,
    -1,
    -1
]);
// double is a bit quicker here as well
const grad4 = /*#__PURE__*/ new Float64Array([
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    -1,
    0,
    1,
    -1,
    1,
    0,
    1,
    -1,
    -1,
    0,
    -1,
    1,
    1,
    0,
    -1,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    0,
    -1,
    -1,
    -1,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    -1,
    1,
    0,
    -1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    -1,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    1,
    -1,
    0,
    1,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    0,
    1,
    -1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    -1,
    1,
    1,
    1,
    0,
    1,
    1,
    -1,
    0,
    1,
    -1,
    1,
    0,
    1,
    -1,
    -1,
    0,
    -1,
    1,
    1,
    0,
    -1,
    1,
    -1,
    0,
    -1,
    -1,
    1,
    0,
    -1,
    -1,
    -1,
    0
]);
function createNoise2D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating this yields a little ~3% performance improvement.
    const permGrad2x = new Float64Array(perm).map((v)=>grad2[v % 12 * 2]);
    const permGrad2y = new Float64Array(perm).map((v)=>grad2[v % 12 * 2 + 1]);
    return function noise2D(x, y) {
        // if(!isFinite(x) || !isFinite(y)) return 0;
        let n0 = 0; // Noise contributions from the three corners
        let n1 = 0;
        let n2 = 0;
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y) * F2; // Hairy factor for 2D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t; // Unskew the cell origin back to (x,y) space
        const Y0 = j - t;
        const x0 = x - X0; // The x,y distances from the cell origin
        const y0 = y - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
        const y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        const ii = i & 255;
        const jj = j & 255;
        // Calculate the contribution from the three corners
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
            const gi0 = ii + perm[jj];
            const g0x = permGrad2x[gi0];
            const g0y = permGrad2y[gi0];
            t0 *= t0;
            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            n0 = t0 * t0 * (g0x * x0 + g0y * y0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
            const gi1 = ii + i1 + perm[jj + j1];
            const g1x = permGrad2x[gi1];
            const g1y = permGrad2y[gi1];
            t1 *= t1;
            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);
            n1 = t1 * t1 * (g1x * x1 + g1y * y1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
            const gi2 = ii + 1 + perm[jj + 1];
            const g2x = permGrad2x[gi2];
            const g2y = permGrad2y[gi2];
            t2 *= t2;
            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);
            n2 = t2 * t2 * (g2x * x2 + g2y * y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 70.0 * (n0 + n1 + n2);
    };
}
function createNoise3D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating these seems to yield a speedup of over 15%
    const permGrad3x = new Float64Array(perm).map((v)=>grad3[v % 12 * 3]);
    const permGrad3y = new Float64Array(perm).map((v)=>grad3[v % 12 * 3 + 1]);
    const permGrad3z = new Float64Array(perm).map((v)=>grad3[v % 12 * 3 + 2]);
    return function noise3D(x, y, z) {
        let n0, n1, n2, n3; // Noise contributions from the four corners
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const k = fastFloor(z + s);
        const t = (i + j + k) * G3;
        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        const Y0 = j - t;
        const Z0 = k - t;
        const x0 = x - X0; // The x,y,z distances from the cell origin
        const y0 = y - Y0;
        const z0 = z - Z0;
        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
        // Determine which simplex we are in.
        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        } else {
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
        // c = 1/6.
        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
        const y2 = y0 - j2 + 2.0 * G3;
        const z2 = z0 - k2 + 2.0 * G3;
        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
        const y3 = y0 - 1.0 + 3.0 * G3;
        const z3 = z0 - 1.0 + 3.0 * G3;
        // Work out the hashed gradient indices of the four simplex corners
        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        // Calculate the contribution from the four corners
        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0) n0 = 0.0;
        else {
            const gi0 = ii + perm[jj + perm[kk]];
            t0 *= t0;
            n0 = t0 * t0 * (permGrad3x[gi0] * x0 + permGrad3y[gi0] * y0 + permGrad3z[gi0] * z0);
        }
        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0) n1 = 0.0;
        else {
            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1]];
            t1 *= t1;
            n1 = t1 * t1 * (permGrad3x[gi1] * x1 + permGrad3y[gi1] * y1 + permGrad3z[gi1] * z1);
        }
        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0) n2 = 0.0;
        else {
            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2]];
            t2 *= t2;
            n2 = t2 * t2 * (permGrad3x[gi2] * x2 + permGrad3y[gi2] * y2 + permGrad3z[gi2] * z2);
        }
        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0) n3 = 0.0;
        else {
            const gi3 = ii + 1 + perm[jj + 1 + perm[kk + 1]];
            t3 *= t3;
            n3 = t3 * t3 * (permGrad3x[gi3] * x3 + permGrad3y[gi3] * y3 + permGrad3z[gi3] * z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return 32.0 * (n0 + n1 + n2 + n3);
    };
}
function createNoise4D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating these leads to a ~10% speedup
    const permGrad4x = new Float64Array(perm).map((v)=>grad4[v % 32 * 4]);
    const permGrad4y = new Float64Array(perm).map((v)=>grad4[v % 32 * 4 + 1]);
    const permGrad4z = new Float64Array(perm).map((v)=>grad4[v % 32 * 4 + 2]);
    const permGrad4w = new Float64Array(perm).map((v)=>grad4[v % 32 * 4 + 3]);
    return function noise4D(x, y, z, w) {
        let n0, n1, n2, n3, n4; // Noise contributions from the five corners
        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
        const s = (x + y + z + w) * F4; // Factor for 4D skewing
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const k = fastFloor(z + s);
        const l = fastFloor(w + s);
        const t = (i + j + k + l) * G4; // Factor for 4D unskewing
        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
        const Y0 = j - t;
        const Z0 = k - t;
        const W0 = l - t;
        const x0 = x - X0; // The x,y,z,w distances from the cell origin
        const y0 = y - Y0;
        const z0 = z - Z0;
        const w0 = w - W0;
        // For the 4D case, the simplex is a 4D shape I won't even try to describe.
        // To find out which of the 24 possible simplices we're in, we need to
        // determine the magnitude ordering of x0, y0, z0 and w0.
        // Six pair-wise comparisons are performed between each possible pair
        // of the four coordinates, and the results are used to rank the numbers.
        let rankx = 0;
        let ranky = 0;
        let rankz = 0;
        let rankw = 0;
        if (x0 > y0) rankx++;
        else ranky++;
        if (x0 > z0) rankx++;
        else rankz++;
        if (x0 > w0) rankx++;
        else rankw++;
        if (y0 > z0) ranky++;
        else rankz++;
        if (y0 > w0) ranky++;
        else rankw++;
        if (z0 > w0) rankz++;
        else rankw++;
        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
        // impossible. Only the 24 indices which have non-zero entries make any sense.
        // We use a thresholding to set the coordinates in turn from the largest magnitude.
        // Rank 3 denotes the largest coordinate.
        // Rank 2 denotes the second largest coordinate.
        // Rank 1 denotes the second smallest coordinate.
        // The integer offsets for the second simplex corner
        const i1 = rankx >= 3 ? 1 : 0;
        const j1 = ranky >= 3 ? 1 : 0;
        const k1 = rankz >= 3 ? 1 : 0;
        const l1 = rankw >= 3 ? 1 : 0;
        // The integer offsets for the third simplex corner
        const i2 = rankx >= 2 ? 1 : 0;
        const j2 = ranky >= 2 ? 1 : 0;
        const k2 = rankz >= 2 ? 1 : 0;
        const l2 = rankw >= 2 ? 1 : 0;
        // The integer offsets for the fourth simplex corner
        const i3 = rankx >= 1 ? 1 : 0;
        const j3 = ranky >= 1 ? 1 : 0;
        const k3 = rankz >= 1 ? 1 : 0;
        const l3 = rankw >= 1 ? 1 : 0;
        // The fifth corner has all coordinate offsets = 1, so no need to compute that.
        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
        const y1 = y0 - j1 + G4;
        const z1 = z0 - k1 + G4;
        const w1 = w0 - l1 + G4;
        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
        const y2 = y0 - j2 + 2.0 * G4;
        const z2 = z0 - k2 + 2.0 * G4;
        const w2 = w0 - l2 + 2.0 * G4;
        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
        const y3 = y0 - j3 + 3.0 * G4;
        const z3 = z0 - k3 + 3.0 * G4;
        const w3 = w0 - l3 + 3.0 * G4;
        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
        const y4 = y0 - 1.0 + 4.0 * G4;
        const z4 = z0 - 1.0 + 4.0 * G4;
        const w4 = w0 - 1.0 + 4.0 * G4;
        // Work out the hashed gradient indices of the five simplex corners
        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        const ll = l & 255;
        // Calculate the contribution from the five corners
        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
        if (t0 < 0) n0 = 0.0;
        else {
            const gi0 = ii + perm[jj + perm[kk + perm[ll]]];
            t0 *= t0;
            n0 = t0 * t0 * (permGrad4x[gi0] * x0 + permGrad4y[gi0] * y0 + permGrad4z[gi0] * z0 + permGrad4w[gi0] * w0);
        }
        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
        if (t1 < 0) n1 = 0.0;
        else {
            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]];
            t1 *= t1;
            n1 = t1 * t1 * (permGrad4x[gi1] * x1 + permGrad4y[gi1] * y1 + permGrad4z[gi1] * z1 + permGrad4w[gi1] * w1);
        }
        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
        if (t2 < 0) n2 = 0.0;
        else {
            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]];
            t2 *= t2;
            n2 = t2 * t2 * (permGrad4x[gi2] * x2 + permGrad4y[gi2] * y2 + permGrad4z[gi2] * z2 + permGrad4w[gi2] * w2);
        }
        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
        if (t3 < 0) n3 = 0.0;
        else {
            const gi3 = ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]];
            t3 *= t3;
            n3 = t3 * t3 * (permGrad4x[gi3] * x3 + permGrad4y[gi3] * y3 + permGrad4z[gi3] * z3 + permGrad4w[gi3] * w3);
        }
        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
        if (t4 < 0) n4 = 0.0;
        else {
            const gi4 = ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]];
            t4 *= t4;
            n4 = t4 * t4 * (permGrad4x[gi4] * x4 + permGrad4y[gi4] * y4 + permGrad4z[gi4] * z4 + permGrad4w[gi4] * w4);
        }
        // Sum up and scale the result to cover the range [-1,1]
        return 27.0 * (n0 + n1 + n2 + n3 + n4);
    };
}
function buildPermutationTable(random) {
    const tableSize = 512;
    const p = new Uint8Array(tableSize);
    for(let i = 0; i < tableSize / 2; i++){
        p[i] = i;
    }
    for(let i = 0; i < tableSize / 2 - 1; i++){
        const r = i + ~~(random() * (256 - i));
        const aux = p[i];
        p[i] = p[r];
        p[r] = aux;
    }
    for(let i = 256; i < tableSize; i++){
        p[i] = p[i - 256];
    }
    return p;
} //# sourceMappingURL=simplex-noise.js.map
}}),

};

//# sourceMappingURL=node_modules_62459cc8._.js.map